安装
	这个网站下https://www.dosbox.com/
  
程序的执行
	执行中间有错误就会报错
	masm是执行,需要源文件,执行后得到 源文件.OBJ结尾的文件
	link是执行,需要 文件.OBJ结尾的文件,执行后得到 文件.exe可执行文件
  
学习语数外
	人类观测世界,用编码对世界进行表示
		用于计算
	语外
		先学会他的读,然后听,下一步是听和写,最后是说和翻译
		文科
			人类社会的学科
	数学
		数学的公式的本质是:表示系统,编码系统
		理科
			自然世界的科学
  
  计算机的编码
	编码是对世界的表示
	计算
		计算要素与计算要素之间的逻辑关系
    
  语言介绍
	汇编语言 观测手段 从机器角度思考问题的,思维方式,是其他高级语言不可替代的
	通过观测 和 不断的做实验 吸收好的表示自己思维的方式
	 从而形成自己的编程思想
	将我们的思维方式 用计算机编程语言 这套表示系统 表示出来而已 
	计算机编程语言 是一套表示系统
		计算机语言的思维方式都非常类似
    
  进制
	进制概念
		每个位是一个位的进制,逢多少进一, 不要超过255,没意义
		特点
			十进制数字后面什么都不加
			二进制数字后面加 B
			十六进制数字后面加 H
			汇编用不到八进制
	十进制
		个    十    百
    10^0  10^1  10^2...
	二进制
		2^0 2^1 2^2...
			1=有 0=无,加快计算速度
			十进制转换二进制
      用短除法除以2,余数就是二进制了要从下往上写(你100这么写的,这个就这么写,0要写)
					一个数字除以2只可能产生0或者1的余数, 这种方法可以推理所有进制的数
			新的快速计算方式(前提是记住2的倍数) 缺点是:数字特别大就不好用了
					先用这个数减去最大的位数并这个位是1,然后减过的数看还能再继续向下的第二大的位数相减,如果能位是1,不能0,不管能不能相减,都会继续向下去看
	十六进制
		16^0 16^1 16^2...
		十进制转换十六进制, 用短除法除以16,余数就是十六进制了, 要从下往上写(你100这么写的,这个就这么写,0要写)
			一个数字除以16只可能产生0~15的余数
		快速的计算方式(前提是记住16的倍数), 缺点就是:数字特别大就不好用
		  同理,但相除最后得到的一定是16的倍数
	十六进制与二进制之间快速相互转换
		16->2
			分割十六进制,每一位十六进制位表示4个二进制位,然后再一合并
		2->16
			分割二进制,每4个二进制位去表示一个16进制位,然后再一合并(没有满足4位,补足4位)
      
基础知识
	再debug中,输入u可以看到
		内存编号 十六进制数字 一些英语单词的简写 + 一些数字
			内存编号为什么是从0开始的
			内存编号又称为内存地址或者是地址线
		mov = move 移动的意思
		ax 是寄存器的意思          两个组合在一起,就是将xxx移动到寄存器中

	汇编语言
		汇编指令
			通过编译器 也就是翻译软件 翻译成 机器指令 机器码
		伪指令
			告诉编译器 也就是翻译软件 你这里怎么翻译 哪里怎么翻译
		符号体制
			+-*/ 编译器管的
		汇编和机器指令有什么关系
			通过编译器,也就是翻译软件 汇编指令可以翻译成机器指令
		针对cpu的什么呢 (学过后面的内容再开看)
			cpu是通过什么方式去访问这些内存空间和端口的呢
				地址线
				数据线
				控制线
				推理出来的
			而且这种地方一定可以存放 地址信息 数据信息 控制信息(但是先不管) 的地方
				这个地方叫寄存器
			汇编程序员就是 通过汇编语言中的 汇编指令去修改寄存器中的 内存从而控制cpu 就可以控制整个计算机了
				在第一节课的时候看过
				mov ax,0005
				ax就是一个数据寄存器
			
	汇编指令放在那里
		内存
			内存中,内存条=主内存 绝大多数 指令和数据 都是存放在内存中的
				指令和数据再内存中是没有任何区别的
		cpu
			cpu中存放了一部分的指令和数据
				问cpu要从内存中读取指令和数据 怎么做? 也就是写入 放回到内存中该怎么做
				需要三种信息
					内存编号信息(地址线,内存地址)
						如果只有一根地址线,物理上限制住了
							一根地址线对应一个字节
						地址线的数量,决定了 你能够找到多大的地址
							寻址能力
								物理上的限制 电路 只能表示0或者1 最小是0了,所以都是从0开始寻找的,所以地址是从0开始的
							如果一根是只能找打2^1的数量
							2 = 2^2
							3 = 2^3
							4 = 2^4
							10根呢 = 2^10 = 0~1023
					数据信息(数据线)
						决定了cpu的 和其他部件 进行数据传送时,一次性能够 传送 多少字节 的能力
							一根数据线对应一个比特
					读写信息(控制线)
						决定了cpu对 其他部件 进行控制的能力
	指令
		u指令
			机器指令和汇编指令
		d指令
			数据
		同一串十六进制数字产生2种解释 指令 数据
		内存的最小单元是什么
			是像74H 03H E9H 是一个字节
			一个字节 = 2个十六进制位 = 8个二进制位
				1b = 8B
                1b = 1个二进制位
计量单位
1B = 8b
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
B = byte
K = kilo
M = million
G = giga
就像光年,你不能说多少个字节,你只能所多少个G或者M

1KB = 2^10B
1MB = 2^20B
1GB = 2^30B
有什么用呢,题目一个cpu的寻址能力为8KB,那么他的总线宽度为
答案是13宽度
解:8=2^3
    1KB=2^10
    2^3 + 2^10 = 2^13
    所以是13个宽度

	遗留的问题
		cpu是怎么区分指令和数据
		内存编号为什么是从0开始的
		内存编号为什么时073F:02CE这样形式
		
加深内存认识
	先看例子
		B800:400 回车
			1空格 1空格 2空格 2空格
			这个操作,内存地址是不是内存条的地址
				明显不是
				计算机有很多部件.内存条是计算机的一个部件,这个操作时是显卡 显存 
	cpu和计算机各个部件之间的关系
		内存条 
		显卡(显存)
		rom内存
		给他们编号来确定它 显存中的内容会显示到显示器上
	什么是RAM内存
		读取与写入,断电后内存中的指令和数据丢失了
	什么是ROM内存(计算机刚开机的时候没有数据应该从什么地方去读呢ram中是没有的所以需要rom内存)
		只允许读取,断电后指令和数据还存在,一般用在 启动计算机上面
		通过内存地址去访问(好像是厂家设置好的内存)
	GPU是如何产生的呢
		gpu也就是图形处理工具, 很久以前是没有的和cpu在一块,现在对图形的要求越来越高,所以分工了,cpu专门进行图形处理(也就是我们常说的显卡)
		我们只用知道
			从B800:0000 400H 当作显存就可以了
			
什么是端口
	cpu是通过内存地址访问外部设备的吗
		不是的,是通过端口port
			外设都有一块芯片 同样也能存储指令和数据
			cpu是一块芯片 存储指令和数据的
		是端口号 假设60H就是端口号
			还有都和端口有关是控制线 读写信息
				input
				out
			补充:和内存有关的是mov
		端口地址和内存地址时分开的,内存地址可以从0~F,端口地址也可以从0~F
			因为端口号采用独立编址
			cpu根据命令来区分是访问内存还是端口,所以才有了input和out
			
命令
	寄存器的分类
		数据寄存器
			ax
		地址寄存器
	debug
		调试,一切的开始
	-u
		机器指令和汇编指令
	-d
		数据
	-r
	-e
	
在debug下-u和-r看到的是
	只看内存编号
		:左边是073F
			但是-r看了一下,DS ES SS CS都是冒号左边的 是一种地址信息,
		:右边是内存地址
			冒号右边的只有一个IP比较像
		写的代码都是修改寄存器中的内容
		
	小总结
		机器指令和数据存放在哪里
			内存
		机器指令是什么形式存放在内存中的
			二进制,为什么再debug中看到的是十六进制,因为方便我们阅读
		内存它的编号是怎么算的
			从0开始
		内存的计量单位
			go
		内存编号为什么是从0开始的
			物理上的限制 电路 只能表示0或者1 最小是0了
		什么叫寻址能力
			地址线的数量 决定了 你能传多少 0或1 决定了 你能够找到多大的地址
		cpu和计算机各个部件之间的关系
			内存条,显卡(显存),rom内存 给他们编号来确定它
			显存中的内容会显示到显示器上.
		什么是RAM内存
			读取与写入,断电后内存中的指令和数据丢失了
		什么是ROM内存
			只允许读取,断电后指令和数据还存在,一般用在 启动计算机上面
			通过内存地址去访问(好像是厂家设置好的内存)
		cpu是通过内存地址访问外部设备的吗
			不是的,是通过端口port
				外设都有一块芯片 同样也能存储指令和数据
				cpu是一块芯片 存储指令和数据的
			是端口号60H就是端口号
				还有都和端口有关是控制线 读写信息
					input
					out
				补充:和内存有关的是mov
			端口地址和内存地址时分开的,内存地址可以从0~F,端口地址也可以从0~F
		cpu可以通过 主板上的电路 读到所有数据,cpu就像人的大脑 主板是人体上的骨骼,主板上的电路是什么 时附加在骨骼上的神经 大脑得到反映cpu得到数据
		针对cpu的什么呢
			cpu内部有保存地址信息和数据信息的地方,叫寄存器,就是针对这个的
			
学习目录(大纲)
	最重要的是观察和思考
	基础知识
		寄存器
		寄存器(内存的访问)
		debug查找错误的工具
		
	编程访问内存空间 也就是访问内存\显存\rom的
		第一个程序
		[BX]和loop指令
		包含多个程序段
		数据处理的两个基本问题
		转移指令的原理
		call和ret指令
		
	第二部分的内容
		标志位寄存器
			承上启下
			必须要有这个,寄存器要去判断某些事情
		内中断
		int指令
	通过端口号读取出来的东西来改变内存空间中的内容 也就是访问\修改外设
		端口
		外中断
		直接定址表
		使用BIOS进行键盘输入和磁盘读写
	总合研究,汇编语言和C语言的关系

寄存器(用的是8086cpu)
 AX,BX,CX,DX数据寄存器 8086一共16根数据线
	它们有个特殊的地方是其他寄存器所没有的
		因为他们呢可以分割为2个8位寄存器
			说一个AX,但是还有BX,CX,DX灵活变通一下
				AH = 高八位构成AH寄存器  h = high
				AL = 低八位构成AL寄存器   l=low
				它们分别在哪里呢,在AX寄存器的左右两边 为什么有8位寄存器,为了兼容以前编写的程序稍加修改
  内存最小单元是8字节
	cpu冲数据中读取一个字节 = 8bit -> 8位寄存器中  字节型数据   0000 0000~1111 1111
  数据线呢  16根数据线
	数据线的宽度决定了cpu一次性能够读取多长的数据
	8086cpu一次性可以处理两种尺寸的数据
	 字节型数据 1B = 8b -> 8位寄存器中
	 字型数据 2B = 16b -> 16位寄存器中
	  两个字节都有称呼分别是,一个字节是这个字型数据的 高位字节(AH,BH,CH,DH),还有一个字节是这个字形数据的 低位字节(AL,BL,CL,DL)

  通用寄存器   一般是存放数据的,数据寄存器   16位寄存器   2字节 = 16bit
  实验   8位数据-8位寄存器   16位数据-16位寄存器
	在使用mov时,要保证数据与寄存器之间的一致性
		mov ax , 给个初始值16进制的,然后用mov bx/ch/dl , 寄存器 (就是切割字型数据,分成字节数据这样赋值)
			只要不是改的同一个寄存器,就不会覆盖,比如,ax,18   ah,78   最后ax=7818
	数据域寄存器之间要 保证一致性,8位寄存器给8位寄存器,8位数据给8位寄存器,16位数据给16位寄存器,16位寄存器给16位寄存器. 如果数据超出8位或者16位的话会报错(数据前面写0如果超了也不行,如果前面不写0,编译器会自动给你补齐,所以没事就不要在前面写0)
	溢出的问题   溢出了,看到的是高位舍弃,但是前面的溢出值跑到其他的地方去了(另一个寄存器存着)
  练习自己找或者自己出题练习去    如:用汇编写出2^4次方去
  16根数据线   每秒传送2字节大小
地址寄存器    16位寄存器    8086一共20根地址线
	段地址寄存器ds,es,ss,cs
	偏移地址寄存器sp,bp,si,di,ip,bx (bx为什么在这里,地址信息也可以当作一种数据,这个要在编程中才会考虑的问题,先不用管)
   20根地址线也就是20位个二进制    也就是2^20,一次找的大小,是1MB大小
   但是寄存器最大是16位,限制的cpu的表达能力,cpu表示不了20根地址线,所以设计者在8086cpu上加东西,这个东西是地址加法器
	加法器是
	 段地址*16(10H) + 偏移地址 = 物理地址    如果段地址过于离谱,那么永远无法找到最终的地址
	 段地址*16 = 基础地址    因为寄存器上限就是16位的,所以段地址最多就是16位的,要找物理地址,好先乘上剩下的地址(要看cpu物理上有多少地址线了)也就是剩下的位也就是1位(这里是16进制,也就是乘16),可以看做成段地址像左移了4位,那么剩下的4位就是让偏移地址去填写去,填写完了就是物理地址了,如果偏移地址为0那基础地址就是物理地址
	基础地址 + 偏移地址 = 物理地址    正好加起来就是20位地址
	一个最终的物理地址只要 段地址*10+偏移地址=物理地址 这个公式,都可以找到相同的最终地址
