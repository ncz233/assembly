安装
	这个网站下https://www.dosbox.com/
  
程序的执行
	执行中间有错误就会报错
	masm是执行,需要源文件,执行后得到 源文件.OBJ结尾的文件
	link是执行,需要 文件.OBJ结尾的文件,执行后得到 文件.exe可执行文件
  
学习语数外
	人类观测世界,用编码对世界进行表示
		用于计算
	语外
		先学会他的读,然后听,下一步是听和写,最后是说和翻译
		文科
			人类社会的学科
	数学
		数学的公式的本质是:表示系统,编码系统
		理科
			自然世界的科学
  
  计算机的编码
	编码是对世界的表示
	计算
		计算要素与计算要素之间的逻辑关系
    
  语言介绍
	汇编语言 观测手段 从机器角度思考问题的,思维方式,是其他高级语言不可替代的
	通过观测 和 不断的做实验 吸收好的表示自己思维的方式
	 从而形成自己的编程思想
	将我们的思维方式 用计算机编程语言 这套表示系统 表示出来而已 
	计算机编程语言 是一套表示系统
		计算机语言的思维方式都非常类似
    
  进制
	进制概念
		每个位是一个位的进制,逢多少进一, 不要超过255,没意义
		特点
			十进制数字后面什么都不加
			二进制数字后面加 B
			十六进制数字后面加 H
			汇编用不到八进制
	十进制
		个    十    百
    10^0  10^1  10^2...
	二进制
		2^0 2^1 2^2...
			1=有 0=无,加快计算速度
			十进制转换二进制
      用短除法除以2,余数就是二进制了要从下往上写(你100这么写的,这个就这么写,0要写)
					一个数字除以2只可能产生0或者1的余数, 这种方法可以推理所有进制的数
			新的快速计算方式(前提是记住2的倍数) 缺点是:数字特别大就不好用了
					先用这个数减去最大的位数并这个位是1,然后减过的数看还能再继续向下的第二大的位数相减,如果能位是1,不能0,不管能不能相减,都会继续向下去看
	十六进制
		16^0 16^1 16^2...
		十进制转换十六进制, 用短除法除以16,余数就是十六进制了, 要从下往上写(你100这么写的,这个就这么写,0要写)
			一个数字除以16只可能产生0~15的余数
		快速的计算方式(前提是记住16的倍数), 缺点就是:数字特别大就不好用
		  同理,但相除最后得到的一定是16的倍数
	十六进制与二进制之间快速相互转换
		16->2
			分割十六进制,每一位十六进制位表示4个二进制位,然后再一合并
		2->16
			分割二进制,每4个二进制位去表示一个16进制位,然后再一合并(没有满足4位,补足4位)
      
基础知识
	再debug中,输入u可以看到
		内存编号 十六进制数字 一些英语单词的简写 + 一些数字
			内存编号为什么是从0开始的
			内存编号又称为内存地址或者是地址线
		mov = move 移动的意思
		ax 是寄存器的意思          两个组合在一起,就是将xxx移动到寄存器中

	汇编语言
		汇编指令
			通过编译器 也就是翻译软件 翻译成 机器指令 机器码
		伪指令
			告诉编译器 也就是翻译软件 你这里怎么翻译 哪里怎么翻译
		符号体制
			+-*/ 编译器管的
		汇编和机器指令有什么关系
			通过编译器,也就是翻译软件 汇编指令可以翻译成机器指令
		针对cpu的什么呢 (学过后面的内容再开看)
			cpu是通过什么方式去访问这些内存空间和端口的呢
				地址线
				数据线
				控制线
				推理出来的
			而且这种地方一定可以存放 地址信息 数据信息 控制信息(但是先不管) 的地方
				这个地方叫寄存器
			汇编程序员就是 通过汇编语言中的 汇编指令去修改寄存器中的 内存从而控制cpu 就可以控制整个计算机了
				在第一节课的时候看过
				mov ax,0005
				ax就是一个数据寄存器
			
	汇编指令放在那里
		内存
			内存中,内存条=主内存 绝大多数 指令和数据 都是存放在内存中的
				指令和数据再内存中是没有任何区别的
		cpu
			cpu中存放了一部分的指令和数据
				问cpu要从内存中读取指令和数据 怎么做? 也就是写入 放回到内存中该怎么做
				需要三种信息
					内存编号信息(地址线,内存地址)
						如果只有一根地址线,物理上限制住了
							一根地址线对应一个字节
						地址线的数量,决定了 你能够找到多大的地址
							寻址能力
								物理上的限制 电路 只能表示0或者1 最小是0了,所以都是从0开始寻找的,所以地址是从0开始的
							如果一根是只能找打2^1的数量
							2 = 2^2
							3 = 2^3
							4 = 2^4
							10根呢 = 2^10 = 0~1023
					数据信息(数据线)
						决定了cpu的 和其他部件 进行数据传送时,一次性能够 传送 多少字节 的能力
							一根数据线对应一个比特
					读写信息(控制线)
						决定了cpu对 其他部件 进行控制的能力
	指令
		u指令
			机器指令和汇编指令
		d指令
			数据
		同一串十六进制数字产生2种解释 指令 数据
		内存的最小单元是什么
			是像74H 03H E9H 是一个字节
			一个字节 = 2个十六进制位 = 8个二进制位
				1b = 8B
                1b = 1个二进制位
计量单位
1B = 8b
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
B = byte
K = kilo
M = million
G = giga
就像光年,你不能说多少个字节,你只能所多少个G或者M

1KB = 2^10B
1MB = 2^20B
1GB = 2^30B
有什么用呢,题目一个cpu的寻址能力为8KB,那么他的总线宽度为
答案是13宽度
解:8=2^3
    1KB=2^10
    2^3 + 2^10 = 2^13
    所以是13个宽度

	遗留的问题
		cpu是怎么区分指令和数据
		内存编号为什么是从0开始的
		内存编号为什么时073F:02CE这样形式
		
加深内存认识
	先看例子
		B800:400 回车
			1空格 1空格 2空格 2空格
			这个操作,内存地址是不是内存条的地址
				明显不是
				计算机有很多部件.内存条是计算机的一个部件,这个操作时是显卡 显存 
	cpu和计算机各个部件之间的关系
		内存条 
		显卡(显存)
		rom内存
		给他们编号来确定它 显存中的内容会显示到显示器上
	什么是RAM内存
		读取与写入,断电后内存中的指令和数据丢失了
	什么是ROM内存(计算机刚开机的时候没有数据应该从什么地方去读呢ram中是没有的所以需要rom内存)
		只允许读取,断电后指令和数据还存在,一般用在 启动计算机上面
		通过内存地址去访问(好像是厂家设置好的内存)
	GPU是如何产生的呢
		gpu也就是图形处理工具, 很久以前是没有的和cpu在一块,现在对图形的要求越来越高,所以分工了,cpu专门进行图形处理(也就是我们常说的显卡)
		我们只用知道
			从B800:0000 400H 当作显存就可以了
			
什么是端口
	cpu是通过内存地址访问外部设备的吗
		不是的,是通过端口port
			外设都有一块芯片 同样也能存储指令和数据
			cpu是一块芯片 存储指令和数据的
		是端口号 假设60H就是端口号
			还有都和端口有关是控制线 读写信息
				input
				out
			补充:和内存有关的是mov
		端口地址和内存地址时分开的,内存地址可以从0~F,端口地址也可以从0~F
			因为端口号采用独立编址
			cpu根据命令来区分是访问内存还是端口,所以才有了input和out
			
命令
	寄存器的分类
		数据寄存器
			ax
		地址寄存器
	debug
		调试,一切的开始
	-u
		机器指令和汇编指令
	-d
		数据
	-r
	-e
	
在debug下-u和-r看到的是
	只看内存编号
		:左边是073F
			但是-r看了一下,DS ES SS CS都是冒号左边的 是一种地址信息,
		:右边是内存地址
			冒号右边的只有一个IP比较像
		写的代码都是修改寄存器中的内容
		
	小总结
		机器指令和数据存放在哪里
			内存
		机器指令是什么形式存放在内存中的
			二进制,为什么再debug中看到的是十六进制,因为方便我们阅读
		内存它的编号是怎么算的
			从0开始
		内存的计量单位
			go
		内存编号为什么是从0开始的
			物理上的限制 电路 只能表示0或者1 最小是0了
		什么叫寻址能力
			地址线的数量 决定了 你能传多少 0或1 决定了 你能够找到多大的地址
		cpu和计算机各个部件之间的关系
			内存条,显卡(显存),rom内存 给他们编号来确定它
			显存中的内容会显示到显示器上.
		什么是RAM内存
			读取与写入,断电后内存中的指令和数据丢失了
		什么是ROM内存
			只允许读取,断电后指令和数据还存在,一般用在 启动计算机上面
			通过内存地址去访问(好像是厂家设置好的内存)
		cpu是通过内存地址访问外部设备的吗
			不是的,是通过端口port
				外设都有一块芯片 同样也能存储指令和数据
				cpu是一块芯片 存储指令和数据的
			是端口号60H就是端口号
				还有都和端口有关是控制线 读写信息
					input
					out
				补充:和内存有关的是mov
			端口地址和内存地址时分开的,内存地址可以从0~F,端口地址也可以从0~F
		cpu可以通过 主板上的电路 读到所有数据,cpu就像人的大脑 主板是人体上的骨骼,主板上的电路是什么 时附加在骨骼上的神经 大脑得到反映cpu得到数据
		针对cpu的什么呢
			cpu内部有保存地址信息和数据信息的地方,叫寄存器,就是针对这个的
			
学习目录(大纲)
	最重要的是观察和思考
	基础知识
		寄存器
		寄存器(内存的访问)
		debug查找错误的工具
		
	编程访问内存空间 也就是访问内存\显存\rom的
		第一个程序
		[BX]和loop指令
		包含多个程序段
		数据处理的两个基本问题
		转移指令的原理
		call和ret指令
		
	第二部分的内容
		标志位寄存器
			承上启下
			必须要有这个,寄存器要去判断某些事情
		内中断
		int指令
	通过端口号读取出来的东西来改变内存空间中的内容 也就是访问\修改外设
		端口
		外中断
		直接定址表
		使用BIOS进行键盘输入和磁盘读写
	总合研究,汇编语言和C语言的关系

寄存器(用的是8086cpu)
 AX,BX,CX,DX数据寄存器 8086一共16根数据线
	它们有个特殊的地方是其他寄存器所没有的
		因为他们呢可以分割为2个8位寄存器
			说一个AX,但是还有BX,CX,DX灵活变通一下
				AH = 高八位构成AH寄存器  h = high
				AL = 低八位构成AL寄存器   l=low
				它们分别在哪里呢,在AX寄存器的左右两边 为什么有8位寄存器,为了兼容以前编写的程序稍加修改
  内存最小单元是8字节
	cpu冲数据中读取一个字节 = 8bit -> 8位寄存器中  字节型数据   0000 0000~1111 1111
  数据线呢  16根数据线
	数据线的宽度决定了cpu一次性能够读取多长的数据
	8086cpu一次性可以处理两种尺寸的数据
	 字节型数据 1B = 8b -> 8位寄存器中
	 字型数据 2B = 16b -> 16位寄存器中
	  两个字节都有称呼分别是,一个字节是这个字型数据的 高位字节(AH,BH,CH,DH),还有一个字节是这个字形数据的 低位字节(AL,BL,CL,DL)

  通用寄存器   一般是存放数据的,数据寄存器   16位寄存器   2字节 = 16bit
  实验   8位数据-8位寄存器   16位数据-16位寄存器
	在使用mov时,要保证数据与寄存器之间的一致性
		mov ax , 给个初始值16进制的,然后用mov bx/ch/dl , 寄存器 (就是切割字型数据,分成字节数据这样赋值)
			只要不是改的同一个寄存器,就不会覆盖,比如,ax,18   ah,78   最后ax=7818
	数据域寄存器之间要 保证一致性,8位寄存器给8位寄存器,8位数据给8位寄存器,16位数据给16位寄存器,16位寄存器给16位寄存器. 如果数据超出8位或者16位的话会报错(数据前面写0如果超了也不行,如果前面不写0,编译器会自动给你补齐,所以没事就不要在前面写0)
	溢出的问题   溢出了,看到的是高位舍弃,但是前面的溢出值跑到其他的地方去了(另一个寄存器存着)
  练习自己找或者自己出题练习去    如:用汇编写出2^4次方去
  16根数据线   每秒传送2字节大小
地址寄存器    16位寄存器    8086一共20根地址线
	段地址寄存器ds,es,ss,cs
	偏移地址寄存器sp,bp,si,di,ip,bx (bx为什么在这里,地址信息也可以当作一种数据,这个要在编程中才会考虑的问题,先不用管)
   20根地址线也就是20位个二进制    也就是2^20,一次找的大小,是1MB大小
   但是寄存器最大是16位,限制的cpu的表达能力,cpu表示不了20根地址线,所以设计者在8086cpu上加东西,这个东西是地址加法器
	加法器是
	 段地址*16(10H) + 偏移地址 = 物理地址    如果段地址过于离谱,那么永远无法找到最终的地址
	 段地址*16 = 基础地址    因为寄存器上限就是16位的,所以段地址最多就是16位的,要找物理地址,好先乘上剩下的地址(要看cpu物理上有多少地址线了)也就是剩下的位也就是1位(这里是16进制,也就是乘16),可以看做成段地址像左移了4位,那么剩下的4位就是让偏移地址去填写去,填写完了就是物理地址了,如果偏移地址为0那基础地址就是物理地址
	基础地址 + 偏移地址 = 物理地址    正好加起来就是20位地址
	一个最终的物理地址只要 段地址*10+偏移地址=物理地址 这个公式,都可以找到相同的最终地址

-u 将某个内存地址 开始的字节 全部当作 指令
-d 将某个内存地址开始的字节 全部当作数据
段地址 和 偏移地址 寄存器
段地址是 = ds,es,ss,cs
偏移地址是 = sp,bp,si,di,ip,bx
已知ip寄存器 和 指令有关
在8086cpu中 在任意时刻 cpu将cs:ip 所指向的内容 全部当作指令来执行
在内存中指令和数据是没有区别的, 都是二进制信息,cpu只有在工作 才将有的信息当作指令
有的信息 当作 数据, cpu根据什么将内容中的数据当作指令的话, cpu将cs:ip 指向的内容单元中的内容当作 指令.
-d查看时内存, -u查看也是内存翻译成汇编指令
用-r把cs:ip改成2000:0就会被当成指令来用了
指令和数据在内存内存中有区别吗? 是没有区别的
到目前位置在cpu中cs段地址寄存器和ip偏移地址寄存器 组合的时候 从中读取内容 当作指令来执行 
sc:ip 决定了cpu从哪里开始读取
总结:cpu任意时刻 段地址寄存器cs和骗你地址寄存器 ip 组合出来的地址 从中读取的内容当作指令

指令是有长度的,一条指令可以由多个字节构成
指令执行的过程中
1.cpu从cs:ip 所指向的内存单元读取指令, 存放到指令缓存器中
2.ip = ip + 所读指令的长度,从而指向 下一条指令
3.执行指令缓存器中的内容,回到步骤1
必须怎么做,要实现一个功能,之后告诉你
实验过后......
现地址表示这个地址的头地址,现地址里有多少个地址,下一个从这个地址开始
ip寄存器和指令长度的关系,在机器编码中2个16进制是1个字节,然后看看这个是多少字节的数据,然后推测出下一个数据的位置
指令是有长度的 一条指令可以由多个字节构成 ip寄存器 和指令长度的关系


遗留下来的问题
指令的执行过程为什么是这么设计的,为的是实现什么功能?
汇编指令jmp = 转移指令可以修改cs和ip这个寄存器,决定了cpu从哪里读取指令
jmp 2000:0
jmp 寄存器(如果直接写一个寄存器,那这个寄存器的值赋值给ip,但是不能是存址寄存器)
寄存器中是不能直接改变mov cs,2000 是不能的,不能直接改地址寄存器
所以应对上面的方式寄存器jmp cs,2000是可以修改的
实验:假设cs=2000,ip=0000写出下列指令的执行过程
右边的都是执行过后得到的也就是步骤3
a 2000:0		cs = 2000	ip = 0
mov ax,6622	cs = 2000	ip = 0+3 = 3
jmp 1000:3	cs = 2000	ip = 3+5 = 8
mov cx,ax		不会执行,因为已经指向了1000:3这个位置了不是cs:ip = 2000:8了
a 1000:0		cs = 1000 ip = 0
mov ax,0123	cs = 1000 ip = 3
mov ax,0		cs = 1000 ip = 3+3 = 6
mov bx,ax		cs = 1000 ip = 6+2 = 8
jmp bx		cs = 1000 ip = 8+2 = A
mov cx,0		不会执行同上,因为指向了1000:0位置了,是一个循环了

指令执行的过程为什么是这样的,为了实现call指令
call cpy_Boot	//转移指令  执行这个指令之后,保存后一个cs:ip指向的指令,保存在内存中,然后跳转到cpy_Boot哪里去继续执行
mov ax,1001
int 21
cpy_Boot: mov bx,1001
	ret	//转移指令 将call跳转的保存的数据拿回,并且去执行cs:ip等于拿回数据的地址


新的问题
执行这个指令之后,保存后一个cs:ip指向的指令,保存在内存中,保存到内存的哪里
检测点2.3
下面3条指令后,cpu几次修改ip?都是在什么时候?最后ip中的值是多少?
sub的意思和add相反就是 -=
mov ax,bx 	->存放到指令缓存中->ip=ip+1->执行 ax = bx
sub ax,ax  	->存放到指令缓存中->ip=ip+1->执行 ax -= ax = 0
jmp ax		->存放到指令缓存中->ip=ip+1->执行 ip = ax = 0
答案4次,ip最后等于0


bebug调试工具
r	可以查看,和改变寄存器中的内容
d	可以查看,内存中的内容(左边是内存地址,中间的是内存地址相对应的内容,右边的是ascii编码(数字符号,英语字母,标点符号))
	(如果是e修改字符了,中间的是ASCII编码,而右边是ASCII编码所对应的字符)
u	可以将内存中的机器指令翻译成汇编指令
a	可以以汇编指令的格式在内存中写入一条汇编指令
t	执行当前cs:ip所指向的机器指令
e	可以改写内存中的内容(可以写字符:-e 段地址:偏移地址 "字符")


试验任务
1.使用debug,将上面的程序段写入内存,逐条执行,观察每条指令执行后,cpu中相关寄存器中内容的变化
可以使用 e 指令 和 a 指令修改,用e也就是机器码编程太傻了,还是用a汇编编程
cpu如何区分指令和数据
机器码	汇编指令
b8 20 4e	mov ax,4e20
05 16 14	add ax,1416
bb 00 20	mov ax,2000
01 d8	add ax,bx
89 c3	mov bx,ax
01 d8	add ax,bx
b8 1a 00	mov ax,001a
bb 26 00 	mov ax,0026
00 d8	add al,bl
00 dc	add ah,bl
00 c7	add bh,al
d4 00	mov ah,0
00 d8	add al,bl
04 9c	add al,9c

2.将下面3条指令写入 从2000:0 开始的单元内存中,利用着3条指令计算2的8次方.  可以这样算2^10是1024,2^9是512少乘以2,所以2^8是256
mov ax,1
add ax,ax
jmp 2000:3

3.向内存中 从b8100 开始的内存单元中填写数据(这个地方是显存的地址)
-e b810:0
01 01 02 02 03 03 04 04

4.查看内存中的内容
pc机主板上的rom中写有一个生产日期,在内存fff00~fffff的某几个单元中
请找出这个生产日期并试图修改它
dos系统,这里是rom内存是不允许写入东西的,以前讲过,rom是开机时候读取的内存,只能读,不能改!


总结承上启下
这章我们学了寄存器
数据寄存器	
地址寄存器	
标志位寄存器	以后讲

数据寄存器有
ax
bx	也可以被当作为 偏移地址寄存器
cx	cx也有其他作用
dx	ax,dx用来处理数据的
也成为通用寄存器
都是16位寄存器,可以各自分割为2个互相独立的8位寄存器
编译器, 为了保证 数据与寄存器之间的 位数一致性 编译器是通过寄存器的位数来判断
所有指令的前提是都要保证数据或寄存器的一致性
mov	移动指令
add	运算指令
它们在运算时可能会 超过 寄存器的 表示最大值  超过的这一部分存放到其他地方去了
寄存器之间时互相独立的

地址寄存器
段地址寄存器 : 便宜地址寄存器	组合规则 组合起来
ds		sp	段地址*16 + 偏移地址 = 物理地址
es		bp	因为时8086cpu 有20根地址线,
ss		si
cs		di
		ip
		bx

cpu 时如何区分指令和数据的
cs:ip这两个寄存器
在任意时刻cpu将 段地址寄存器cs 和 便宜地址寄存器ip 所组合起来的地址 从中读取的内容
全部当作 指令来 执行
指令是有长度的 跟ip寄存器有关
可以修改cs ip这两个寄存器的指令
转移指令
jmp	2000:0
jmp	寄存器格式 (放到ip中,类似于 mov ip,ax 虽然是不能这么做的)

call	xxxxxx 指令执行的过程 ->改变的ip保存了起来也即是保存了步骤2的ip 跳转
1.cpu从cs:ip 所指向的内存单元读取指令, 存放到指令缓存器中
2.ip = ip + 所读指令的长度,从而指向 下一条指令
3.执行指令缓存器中的内容,回到步骤1
改变的ip保存到内存中(下一章讲)
寄存器(访问呢内存)就是讲解这个问题 可以推理出来的东西 除了cs寄存器地方存的

指令和数据存放在内存中是没有任何区别的
是我们汇编程序员 通过修改寄存器中的内容也就是地址寄存器, 告诉cpu数据在哪里,指令在哪里


第三章,寄存器(内存的访问)
前几章遗留的问题
call指令将ip(如:000b)存放到哪里去了(内存的哪里) ret可以拿回
数据长度
字节型数据 = 1B
字型数据 = 2B
在内存中排列
	高位字节:如ah
	低位字节:如al
一个字型数据 存放在内存中 可以由 2个连续的地址单元组成
高地址 内存单元存放 字节型数据的 高位字节
低地址 内存单元存放 字节型数据的 低位字节
如mov ax,1a2b 存放到内存中的是 2b 1a 而他们所对应的地址是如:2b=01 1a=02(16进制)


练习
字节数据 字型数据
内存地址去访问内存 8086cpu 段地址和偏移地址
使用ds段地址寄存器 访问数据用的 c的数组原理就是这么来的
mov al,ds:[0]	mov移动指令 cpu中的al寄存器,内存地址(段地址:[偏移地址]) 意思是将段地址和偏移地址进行组合得到的物理地址
mov al,ds:[1]	中括号[]的意思是得到物理地址里面的内容
mov al,ds:[2]	cpu读取了多长的数据? 一个字节因为案al是8位寄存器
mov al,ds:[3]	但是在debug不允许这么写,要写成mov al,[0]
mov bx,1000	在debug不能mov ds,1000这么写,
mov ds,bx 	r ds可以修改,但是,他不是汇编指令,是debug工具提供的模拟功能,指令是和汇编相关的
mov ax,ds:[0]	cpu读取了一个字型数据,因为是一个字型数据
mov ax,ds:[1]
mov ax,ds:[2]
mov ax,ds:[3]
mov ds:[0],ax	反过来了,同理	
mov ds:[1],ax
mov ds:[0],al
mov ds:[1],ah


练习2
写出下面的指令后 寄存器ax,bx,cx中的值
mov ax,1000	确定了段地址,经过寄存器来判断是字型还是字节型数据
mov ds,ax 	物理地址	内容
mov ax,ds:[0]	10000	23	[0] = 1123 ax=1123
mov bx,ds:[2]	10001	11	[1] = 2211 cx=2211
mov cx,ds:[1]	10002	22	[2] = 6622 bx=6622
add dx,ds:[1]	10003	66
add cx,ds:[2]
不论是移动还是运算,首先要确定数据的长度,通过寄存器来确定

写出下面的指令执行后 内存中 的值
mov ax,1000
mov ds,ax		段地址
mov ax,2c34	物理地址	内容	ax=2c34
mov ds:[0],ax	10000	22   34
mov bx,ds:[0]	10001	11   2c	dx=2c34
sub bx,ds:[2]	10002	22   12	dx=2c34-1122=1b12
mov ds:[2],bx	10003	11   1b

数据段 变成时候一种数据安排
mov ax,123b
mov ds,ax
mov al,0
add al,ds:[0]
add al,ds:[1]
add al,ds:[2]

mov ax,123b
mov ds,ax
mov ax,0
add ax,ds:[0]
add ax,ds:[2]
add ax,ds:[4]


与这章的前面几节小结
字节型数据 字型数据 在内存中的存放
字型数据 在内存中存储时,需要两个地址连续的内存单元存放
高位字节 存放到 高地址中
低位字节 存放到 低地址中

mov add sub 实验
数据的长度 内存中的排列不同 如
字节型数据是 01
字型数据是 01 00

ds 段地址寄存器 也可以说 数据段地址寄存器
cs 指令有关
其他和数据有关

指令和数据在内存中是没有任何区别的 ds:[0] ds[1]读写都学了 也可以把寄存器中的数据保存起来 也可以把寄存器中的数据保存到某个地方去,因为指令和数据在内存中是没有区别的
以后编程的时候慢慢学

写的命令格式,别死记硬背
mov 寄存器,数据		mov ax,1
mov 寄存器,寄存器		mov ax,bx
mov 寄存器,内存单元		mov bx,ds:[0]
mov 内存单元,寄存器		mov ds:[1],cx
mov 段寄存器,寄存器		mov ds,dx
add 寄存器,数据		add ax,1a
add 寄存器,寄存器		add bx,cx
add 寄存器,内存单元		add cx,ds:[2]
add 内存单元,寄存器		add ds:[3],dx
sub 寄存器,数据		sub ax,2b
sub 寄存器,寄存器		sub bx,cx
sub 寄存器,内存单元		sub cx,ds:[4]
sub 内存单元,寄存器		sub ds:[5],dx

有debug这个工具,当你想用某中格式的指令,去debug中尝试
cs:ip 指令从哪里来
ds 数据从哪里来
修改寄存器中的内容去控制cpu 控制整个计算机 读取一个字节 读取一个字


监测点3.1
在debug中,用d 0:0 1f 查看内存
下面的指令执行前 ax=0 bx=0 写出每条汇编指令执行完后相关寄存器中的值
cpu和内存中间的交互
注意数据从哪里来 内存地址
数据的长度 字节型数据还是字型数据
寄存器是互相独立的
-d 1:0地址是
0   1   2   3   4   5   6   7   8  9   a   b  c  d   e  f
08 00 70 00 60 10 00 f0 60 10 00 f0 60 10 00 f0
mov ax,1
mov ds,ax		确定了内存你地址中的物理地址0001:0000 = 0000:0010
mov ax,ds:[0]	字型数据   ax=0008
mov bx,ds:[1]	bx=7000
mov ax,bx		ax=7000
mov ax,ds:[0]	ax=0008
mov bx,ds:[2]	bx=0070
add ax,bx		ax=0078
add ax,ds:[4]	ax=1060
mov ax,0		ax=0
mov al,ds:[2]	字节型数据   al=70
mov bx,0		bx=0
mov bl,ds:[c]	bl=60
add al,bl		al=d0

内存中的情况如下 
CS = 2000H 
		IP = 0 
				DS = 1000H 
						AX = 0		 BX =	0

物理地址 				物理地址
10000H 	B8	mov ax,2000H	20000H	B8	mov ax,6622H	
10001H	00			20001H	22	
10002H	20			20002H	66
10003H	8E	mov ds,ax		20003H	EA	jmp 0FF0:0100H
10004H	D8			20004H	00	
10005H	A1	mov ax,[0008]	20005H	01
10006H	08			20006H	F0
10007H	00			20007H	0F
10008H	A1	mov ax,[0002]	20008H	89	mov bx,ax
10009H	02			20009H	C3
1000AH	00			2000AH
写出cpu执行指令的序列(汇编指令写出)
jmp 1000:0
cs:ip 
mov ax,6622H
jmp 0FF0:0100H
mov ax,2000H
mov ds,ax
mov ax,[0008]
mov ax,[0002]

写出cpu执行每条指令后,cs:ip和相关寄存器中的数值 
从cs:ip 所指向的内存单元读取指令, 指令存放到指令缓存器中
ip = ip+所读指令的长度 字节数
执行指令缓存器中的内容,回到第一步
ax 6622 2000 c389 ea66
bx 
cs 2000 2000 1000 1000 1000 1000(只用写步骤2 的ip地址)
ip 3       8      3       5       8      b
ds 2000 2000

再次体会数据和指令之间有区别吗?如何确定内存中的信息那些是数据,那些是指令?
没有区别,在cs:ip中读取的是指令,在ds:[偏移地址]中读取的是数据
汇编指令去修改寄存器中的内容 数据从哪里来 指令从哪里来


栈的概念
栈是一段连续的内存单元,也就是一段连续的内存地址
为什么起一个非常专业的名字呢?
特殊在他的访问形式上
mov 移动指令 区别最大的地方
mov ax,1000
mov ds,ax
mov ax,ds:[0]
mov ax,ds:[1]
要有怀疑和实践的精神前面所学反驳

前几章遗留的问题
call指令将ip(如:000b)存放到哪里去了(内存的哪里) ret可以拿回
通过程序的角度去看栈
最后入栈的数据一定会放到栈顶
我们可以为栈顶的最上面的数据的位置做一个标记
标记代表了箱子中最上面的数据在栈中的位置
出栈肯定是箱子中最上面的数据拿走,然后栈顶标记指向下一个位置的
术语 栈顶标记 栈 入栈 出栈
由于不断的入栈 或者 出栈我们需要不断的修改栈顶标记 来确定栈中最上面的数据 在栈中的位置

内存的角度将栈的概念
入栈 push	将16位寄存器 或者 内存中的 字型数据 -> 栈顶标记标记的上面 修改栈顶标记
出栈 pop	将栈顶标记 所标识 的 字型数据 -> 16位寄存器 或者 内存中 修改栈顶标记

存放数据的
数据从哪里来 寄存器中 内存中
数据的长度 字节型数据 字型数据? 是字型数据,只能用字型数据,用al bh是不行的
栈顶标记在 入栈和出栈时 所扮演的角色去 理解这个问题

入栈时 决定了 你放的数据的存放位置(内存地址) -> 栈顶标记的上面 修改栈顶标记
出栈时 决定了 你拿走数据的位置(内存地址) -> 修改栈顶标记
来确定栈中最上面的数据 在栈中的位置(内存地址)
栈顶标记 是 内存地址 = 段地址 和 偏移地址来表示
在8086cpu中 在任意时刻 将 段地址寄存器ss 和 偏移地址寄存器 sp 所组合起来的地址 当作栈顶标记
push ax	修改sp寄存器中的数据sp=sp-2, 为什么-2,因为一个字型是2个字节长度
	将ax中字型数据 -> ss:sp所组合处理啊的内存地址中 入栈
pop bx	ss:sp所组合出来的内存地址 中的 字型数据 -> bx
	修改栈顶标记 sp = sp+2 成为新的栈顶标记 出栈, 同理+2是弹出,弹出1个字型长度一个所以+2
数据从哪里来 寄存器中 内存中
数据的长度 字型数据
mov ax,2233
push ax
pop bx
得到的是 ax=2233 ss:(sp-2)=33 22 bx=2233

在实验的时候如果改变了bp si di寄存器中的数据,也会改变栈中的数据, 这要后面讲,因为我们现在缺少解决问题想法的基础

在8086cpu中 在任意时刻 将 段地址寄存器ss 和 偏移地址寄存器 sp 所组合起来的地址 当作栈顶标记
栈在哪里是我决定的,容量大小也是我决定的
在之前我们决定cs:ip是cpu从哪里读取指令
是可以用转移指令去修改
所以我们也可以决定栈顶标记在哪里,栈在哪里,栈的大小
假设sp = 10H
16B = 8字节数据 push可以操作8次
起始地址+你所设定的栈的大小的 字节数
0000 + 16(10H) = 10H
ss:sp所组合出来的栈顶标记
mov ax,2000
mov ss,ax
mov sp,10
mov ax,2233
push ax
push ax
push ax
pop bx
pop cx
pop dx
在设置ss寄存器的时候会立即执行下一步就可以了,连续执行是为了控制栈段大小,防止程序调用时出错
讲了,栈时如何设置的 最好设置成16的倍数,自己的一个约定,放置一些 稀奇古怪的 问题出现

栈的越界问题
mov ax,2000
mov ss,ax
mov sp,8
mov ax,2233
push ax
push ax
push ax
push ax
push ax
最后我们看到sp=fffe了,超出了栈,栈溢出了,有可能会覆盖掉fffe这个位置上的关键数据或者指令,导致了程序无法启动
其他地方可能存放着指令或者数据由于一直push或者pop破坏了这个栈,从而导致了一连串的错误
有没有 栈的上限 或者 下限的 寄存器 来确定栈的大小来帮助我们判断一下从而就不会栈的越界问题?
实际的情况是8086cpu在任意情况是将 段地址寄存器ss 和 偏移地址寄存器 sp 所组合起来的地址 当作栈顶标记,所以是没有的
所以我们在编程的时候一定要小心栈的操作,要根据可能用到的栈的最大空间去安排栈的大小,从而去避免栈顶的越界问题

栈的极限大小,因push和pop影响的是sp寄存器,所以也可以问成sp的寄存器的变化范围是多少
sp的寄存器的变化范围, 0~ffffH 要除以2,因为65536是字节,而我们要存的是字型数据,所以是32768
假设ss=2000 sp=? 已知sp要取最大值,然后每次push运行前都需要-2,所以要ffff+2?是吗,答案是0,因为,最好是16的倍数,并且这是一个环形栈
就是设置一个可以存放32768个字型数据的栈 一共65536个字节=64K
sp如果超出了,也就是栈顶的越界, 覆盖了原来栈中的内容

栈的作用
前几章遗留的问题
call指令将ip(如:000b)存放到哪里去了(内存的哪里) ret可以拿回
临时性保存数据,知道了可以保存call存放的指令了
就是如果我们在call外设置了ax,bx这些数据寄存器了,然后再call里又设置了ax,bx这些数据寄存器,的话当call执行完,想用外边的数据寄存器里的数据就已经发生改变.所以我们要用到栈,再改变前需要将数据寄存器中的数据放到栈中(push),想要拿回之前的数据(pop)就可以得到改变前的数据了

mov ax,1000
mov bx,2000
push ax
push bx 注意入栈顺序
mov ax,0
mov bx,0
pop bx
pop ax 注意出栈顺序

mov ax,1122
mov bx,3344
push ax
push bx
pop ax
pop bx
