安装
	这个网站下https://www.dosbox.com/
  
程序的执行
	执行中间有错误就会报错
	masm是执行,需要源文件,执行后得到 源文件.OBJ结尾的文件
	link是执行,需要 文件.OBJ结尾的文件,执行后得到 文件.exe可执行文件
  
学习语数外
	人类观测世界,用编码对世界进行表示
		用于计算
	语外
		先学会他的读,然后听,下一步是听和写,最后是说和翻译
		文科
			人类社会的学科
	数学
		数学的公式的本质是:表示系统,编码系统
		理科
			自然世界的科学
  
  计算机的编码
	编码是对世界的表示
	计算
		计算要素与计算要素之间的逻辑关系
    
  语言介绍
	汇编语言 观测手段 从机器角度思考问题的,思维方式,是其他高级语言不可替代的
	通过观测 和 不断的做实验 吸收好的表示自己思维的方式
	 从而形成自己的编程思想
	将我们的思维方式 用计算机编程语言 这套表示系统 表示出来而已 
	计算机编程语言 是一套表示系统
		计算机语言的思维方式都非常类似
    
  进制
	进制概念
		每个位是一个位的进制,逢多少进一, 不要超过255,没意义
		特点
			十进制数字后面什么都不加
			二进制数字后面加 B
			十六进制数字后面加 H
			汇编用不到八进制
	十进制
		个    十    百
    10^0  10^1  10^2...
	二进制
		2^0 2^1 2^2...
			1=有 0=无,加快计算速度
			十进制转换二进制
      用短除法除以2,余数就是二进制了要从下往上写(你100这么写的,这个就这么写,0要写)
					一个数字除以2只可能产生0或者1的余数, 这种方法可以推理所有进制的数
			新的快速计算方式(前提是记住2的倍数) 缺点是:数字特别大就不好用了
					先用这个数减去最大的位数并这个位是1,然后减过的数看还能再继续向下的第二大的位数相减,如果能位是1,不能0,不管能不能相减,都会继续向下去看
	十六进制
		16^0 16^1 16^2...
		十进制转换十六进制, 用短除法除以16,余数就是十六进制了, 要从下往上写(你100这么写的,这个就这么写,0要写)
			一个数字除以16只可能产生0~15的余数
		快速的计算方式(前提是记住16的倍数), 缺点就是:数字特别大就不好用
		  同理,但相除最后得到的一定是16的倍数
	十六进制与二进制之间快速相互转换
		16->2
			分割十六进制,每一位十六进制位表示4个二进制位,然后再一合并
		2->16
			分割二进制,每4个二进制位去表示一个16进制位,然后再一合并(没有满足4位,补足4位)
      
基础知识
	再debug中,输入u可以看到
		内存编号 十六进制数字 一些英语单词的简写 + 一些数字
			内存编号为什么是从0开始的
			内存编号又称为内存地址或者是地址线
		mov = move 移动的意思
		ax 是寄存器的意思          两个组合在一起,就是将xxx移动到寄存器中

	汇编语言
		汇编指令
			通过编译器 也就是翻译软件 翻译成 机器指令 机器码
		伪指令
			告诉编译器 也就是翻译软件 你这里怎么翻译 哪里怎么翻译
		符号体制
			+-*/ 编译器管的
		汇编和机器指令有什么关系
			通过编译器,也就是翻译软件 汇编指令可以翻译成机器指令
		针对cpu的什么呢 (学过后面的内容再开看)
			cpu是通过什么方式去访问这些内存空间和端口的呢
				地址线
				数据线
				控制线
				推理出来的
			而且这种地方一定可以存放 地址信息 数据信息 控制信息(但是先不管) 的地方
				这个地方叫寄存器
			汇编程序员就是 通过汇编语言中的 汇编指令去修改寄存器中的 内存从而控制cpu 就可以控制整个计算机了
				在第一节课的时候看过
				mov ax,0005
				ax就是一个数据寄存器
			
	汇编指令放在那里
		内存
			内存中,内存条=主内存 绝大多数 指令和数据 都是存放在内存中的
				指令和数据再内存中是没有任何区别的
		cpu
			cpu中存放了一部分的指令和数据
				问cpu要从内存中读取指令和数据 怎么做? 也就是写入 放回到内存中该怎么做
				需要三种信息
					内存编号信息(地址线,内存地址)
						如果只有一根地址线,物理上限制住了
							一根地址线对应一个字节
						地址线的数量,决定了 你能够找到多大的地址
							寻址能力
								物理上的限制 电路 只能表示0或者1 最小是0了,所以都是从0开始寻找的,所以地址是从0开始的
							如果一根是只能找打2^1的数量
							2 = 2^2
							3 = 2^3
							4 = 2^4
							10根呢 = 2^10 = 0~1023
					数据信息(数据线)
						决定了cpu的 和其他部件 进行数据传送时,一次性能够 传送 多少字节 的能力
							一根数据线对应一个比特
					读写信息(控制线)
						决定了cpu对 其他部件 进行控制的能力
	指令
		u指令
			机器指令和汇编指令
		d指令
			数据
		同一串十六进制数字产生2种解释 指令 数据
		内存的最小单元是什么
			是像74H 03H E9H 是一个字节
			一个字节 = 2个十六进制位 = 8个二进制位
				1b = 8B
                1b = 1个二进制位
计量单位
1B = 8b
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
B = byte
K = kilo
M = million
G = giga
就像光年,你不能说多少个字节,你只能所多少个G或者M

1KB = 2^10B
1MB = 2^20B
1GB = 2^30B
有什么用呢,题目一个cpu的寻址能力为8KB,那么他的总线宽度为
答案是13宽度
解:8=2^3
    1KB=2^10
    2^3 + 2^10 = 2^13
    所以是13个宽度

	遗留的问题
		cpu是怎么区分指令和数据
		内存编号为什么是从0开始的
		内存编号为什么时073F:02CE这样形式
		
加深内存认识
	先看例子
		B800:400 回车
			1空格 1空格 2空格 2空格
			这个操作,内存地址是不是内存条的地址
				明显不是
				计算机有很多部件.内存条是计算机的一个部件,这个操作时是显卡 显存 
	cpu和计算机各个部件之间的关系
		内存条 
		显卡(显存)
		rom内存
		给他们编号来确定它 显存中的内容会显示到显示器上
	什么是RAM内存
		读取与写入,断电后内存中的指令和数据丢失了
	什么是ROM内存(计算机刚开机的时候没有数据应该从什么地方去读呢ram中是没有的所以需要rom内存)
		只允许读取,断电后指令和数据还存在,一般用在 启动计算机上面
		通过内存地址去访问(好像是厂家设置好的内存)
	GPU是如何产生的呢
		gpu也就是图形处理工具, 很久以前是没有的和cpu在一块,现在对图形的要求越来越高,所以分工了,cpu专门进行图形处理(也就是我们常说的显卡)
		我们只用知道
			从B800:0000 400H 当作显存就可以了
			
什么是端口
	cpu是通过内存地址访问外部设备的吗
		不是的,是通过端口port
			外设都有一块芯片 同样也能存储指令和数据
			cpu是一块芯片 存储指令和数据的
		是端口号 假设60H就是端口号
			还有都和端口有关是控制线 读写信息
				input
				out
			补充:和内存有关的是mov
		端口地址和内存地址时分开的,内存地址可以从0~F,端口地址也可以从0~F
			因为端口号采用独立编址
			cpu根据命令来区分是访问内存还是端口,所以才有了input和out
			
命令
	寄存器的分类
		数据寄存器
			ax
		地址寄存器
	debug
		调试,一切的开始
	-u
		机器指令和汇编指令
	-d
		数据
	-r
	-e
	
在debug下-u和-r看到的是
	只看内存编号
		:左边是073F
			但是-r看了一下,DS ES SS CS都是冒号左边的 是一种地址信息,
		:右边是内存地址
			冒号右边的只有一个IP比较像
		写的代码都是修改寄存器中的内容
		
	小总结
		机器指令和数据存放在哪里
			内存
		机器指令是什么形式存放在内存中的
			二进制,为什么再debug中看到的是十六进制,因为方便我们阅读
		内存它的编号是怎么算的
			从0开始
		内存的计量单位
			go
		内存编号为什么是从0开始的
			物理上的限制 电路 只能表示0或者1 最小是0了
		什么叫寻址能力
			地址线的数量 决定了 你能传多少 0或1 决定了 你能够找到多大的地址
		cpu和计算机各个部件之间的关系
			内存条,显卡(显存),rom内存 给他们编号来确定它
			显存中的内容会显示到显示器上.
		什么是RAM内存
			读取与写入,断电后内存中的指令和数据丢失了
		什么是ROM内存
			只允许读取,断电后指令和数据还存在,一般用在 启动计算机上面
			通过内存地址去访问(好像是厂家设置好的内存)
		cpu是通过内存地址访问外部设备的吗
			不是的,是通过端口port
				外设都有一块芯片 同样也能存储指令和数据
				cpu是一块芯片 存储指令和数据的
			是端口号60H就是端口号
				还有都和端口有关是控制线 读写信息
					input
					out
				补充:和内存有关的是mov
			端口地址和内存地址时分开的,内存地址可以从0~F,端口地址也可以从0~F
		cpu可以通过 主板上的电路 读到所有数据,cpu就像人的大脑 主板是人体上的骨骼,主板上的电路是什么 时附加在骨骼上的神经 大脑得到反映cpu得到数据
		针对cpu的什么呢
			cpu内部有保存地址信息和数据信息的地方,叫寄存器,就是针对这个的
			
学习目录(大纲)
	最重要的是观察和思考
	基础知识
		寄存器
		寄存器(内存的访问)
		debug查找错误的工具
		
	编程访问内存空间 也就是访问内存\显存\rom的
		第一个程序
		[BX]和loop指令
		包含多个程序段
		数据处理的两个基本问题
		转移指令的原理
		call和ret指令
		
	第二部分的内容
		标志位寄存器
			承上启下
			必须要有这个,寄存器要去判断某些事情
		内中断
		int指令
	通过端口号读取出来的东西来改变内存空间中的内容 也就是访问\修改外设
		端口
		外中断
		直接定址表
		使用BIOS进行键盘输入和磁盘读写
	总合研究,汇编语言和C语言的关系

寄存器(用的是8086cpu)
 AX,BX,CX,DX数据寄存器 8086一共16根数据线
	它们有个特殊的地方是其他寄存器所没有的
		因为他们呢可以分割为2个8位寄存器
			说一个AX,但是还有BX,CX,DX灵活变通一下
				AH = 高八位构成AH寄存器  h = high
				AL = 低八位构成AL寄存器   l=low
				它们分别在哪里呢,在AX寄存器的左右两边 为什么有8位寄存器,为了兼容以前编写的程序稍加修改
  内存最小单元是8字节
	cpu冲数据中读取一个字节 = 8bit -> 8位寄存器中  字节型数据   0000 0000~1111 1111
  数据线呢  16根数据线
	数据线的宽度决定了cpu一次性能够读取多长的数据
	8086cpu一次性可以处理两种尺寸的数据
	 字节型数据 1B = 8b -> 8位寄存器中
	 字型数据 2B = 16b -> 16位寄存器中
	  两个字节都有称呼分别是,一个字节是这个字型数据的 高位字节(AH,BH,CH,DH),还有一个字节是这个字形数据的 低位字节(AL,BL,CL,DL)

  通用寄存器   一般是存放数据的,数据寄存器   16位寄存器   2字节 = 16bit
  实验   8位数据-8位寄存器   16位数据-16位寄存器
	在使用mov时,要保证数据与寄存器之间的一致性
		mov ax , 给个初始值16进制的,然后用mov bx/ch/dl , 寄存器 (就是切割字型数据,分成字节数据这样赋值)
			只要不是改的同一个寄存器,就不会覆盖,比如,ax,18   ah,78   最后ax=7818
	数据域寄存器之间要 保证一致性,8位寄存器给8位寄存器,8位数据给8位寄存器,16位数据给16位寄存器,16位寄存器给16位寄存器. 如果数据超出8位或者16位的话会报错(数据前面写0如果超了也不行,如果前面不写0,编译器会自动给你补齐,所以没事就不要在前面写0)
	溢出的问题   溢出了,看到的是高位舍弃,但是前面的溢出值跑到其他的地方去了(另一个寄存器存着)
  练习自己找或者自己出题练习去    如:用汇编写出2^4次方去
  16根数据线   每秒传送2字节大小
地址寄存器    16位寄存器    8086一共20根地址线
	段地址寄存器ds,es,ss,cs
	偏移地址寄存器sp,bp,si,di,ip,bx (bx为什么在这里,地址信息也可以当作一种数据,这个要在编程中才会考虑的问题,先不用管)
   20根地址线也就是20位个二进制    也就是2^20,一次找的大小,是1MB大小
   但是寄存器最大是16位,限制的cpu的表达能力,cpu表示不了20根地址线,所以设计者在8086cpu上加东西,这个东西是地址加法器
	加法器是
	 段地址*16(10H) + 偏移地址 = 物理地址    如果段地址过于离谱,那么永远无法找到最终的地址
	 段地址*16 = 基础地址    因为寄存器上限就是16位的,所以段地址最多就是16位的,要找物理地址,好先乘上剩下的地址(要看cpu物理上有多少地址线了)也就是剩下的位也就是1位(这里是16进制,也就是乘16),可以看做成段地址像左移了4位,那么剩下的4位就是让偏移地址去填写去,填写完了就是物理地址了,如果偏移地址为0那基础地址就是物理地址
	基础地址 + 偏移地址 = 物理地址    正好加起来就是20位地址
	一个最终的物理地址只要 段地址*10+偏移地址=物理地址 这个公式,都可以找到相同的最终地址

-u 将某个内存地址 开始的字节 全部当作 指令
-d 将某个内存地址开始的字节 全部当作数据
段地址 和 偏移地址 寄存器
段地址是 = ds,es,ss,cs
偏移地址是 = sp,bp,si,di,ip,bx
已知ip寄存器 和 指令有关
在8086cpu中 在任意时刻 cpu将cs:ip 所指向的内容 全部当作指令来执行
在内存中指令和数据是没有区别的, 都是二进制信息,cpu只有在工作 才将有的信息当作指令
有的信息 当作 数据, cpu根据什么将内容中的数据当作指令的话, cpu将cs:ip 指向的内容单元中的内容当作 指令.
-d查看时内存, -u查看也是内存翻译成汇编指令
用-r把cs:ip改成2000:0就会被当成指令来用了
指令和数据在内存内存中有区别吗? 是没有区别的
到目前位置在cpu中cs段地址寄存器和ip偏移地址寄存器 组合的时候 从中读取内容 当作指令来执行 
sc:ip 决定了cpu从哪里开始读取
总结:cpu任意时刻 段地址寄存器cs和骗你地址寄存器 ip 组合出来的地址 从中读取的内容当作指令

指令是有长度的,一条指令可以由多个字节构成
指令执行的过程中
1.cpu从cs:ip 所指向的内存单元读取指令, 存放到指令缓存器中
2.ip = ip + 所读指令的长度,从而指向 下一条指令
3.执行指令缓存器中的内容,回到步骤1
必须怎么做,要实现一个功能,之后告诉你
实验过后......
现地址表示这个地址的头地址,现地址里有多少个地址,下一个从这个地址开始
ip寄存器和指令长度的关系,在机器编码中2个16进制是1个字节,然后看看这个是多少字节的数据,然后推测出下一个数据的位置
指令是有长度的 一条指令可以由多个字节构成 ip寄存器 和指令长度的关系


遗留下来的问题
指令的执行过程为什么是这么设计的,为的是实现什么功能?
汇编指令jmp = 转移指令可以修改cs和ip这个寄存器,决定了cpu从哪里读取指令
jmp 2000:0
jmp 寄存器(如果直接写一个寄存器,那这个寄存器的值赋值给ip,但是不能是存址寄存器)
寄存器中是不能直接改变mov cs,2000 是不能的,不能直接改地址寄存器
所以应对上面的方式寄存器jmp cs,2000是可以修改的
实验:假设cs=2000,ip=0000写出下列指令的执行过程
右边的都是执行过后得到的也就是步骤3
a 2000:0		cs = 2000	ip = 0
mov ax,6622	cs = 2000	ip = 0+3 = 3
jmp 1000:3	cs = 2000	ip = 3+5 = 8
mov cx,ax		不会执行,因为已经指向了1000:3这个位置了不是cs:ip = 2000:8了
a 1000:0		cs = 1000 ip = 0
mov ax,0123	cs = 1000 ip = 3
mov ax,0		cs = 1000 ip = 3+3 = 6
mov bx,ax		cs = 1000 ip = 6+2 = 8
jmp bx		cs = 1000 ip = 8+2 = A
mov cx,0		不会执行同上,因为指向了1000:0位置了,是一个循环了

指令执行的过程为什么是这样的,为了实现call指令
call cpy_Boot	//转移指令  执行这个指令之后,保存后一个cs:ip指向的指令,保存在内存中,然后跳转到cpy_Boot哪里去继续执行
mov ax,1001
int 21
cpy_Boot: mov bx,1001
	ret	//转移指令 将call跳转的保存的数据拿回,并且去执行cs:ip等于拿回数据的地址


新的问题
执行这个指令之后,保存后一个cs:ip指向的指令,保存在内存中,保存到内存的哪里
检测点2.3
下面3条指令后,cpu几次修改ip?都是在什么时候?最后ip中的值是多少?
sub的意思和add相反就是 -=
mov ax,bx 	->存放到指令缓存中->ip=ip+1->执行 ax = bx
sub ax,ax  	->存放到指令缓存中->ip=ip+1->执行 ax -= ax = 0
jmp ax		->存放到指令缓存中->ip=ip+1->执行 ip = ax = 0
答案4次,ip最后等于0


bebug调试工具
r	可以查看,和改变寄存器中的内容
d	可以查看,内存中的内容(左边是内存地址,中间的是内存地址相对应的内容,右边的是ascii编码(数字符号,英语字母,标点符号))
	(如果是e修改字符了,中间的是ASCII编码,而右边是ASCII编码所对应的字符)
u	可以将内存中的机器指令翻译成汇编指令
a	可以以汇编指令的格式在内存中写入一条汇编指令
t	执行当前cs:ip所指向的机器指令
e	可以改写内存中的内容(可以写字符:-e 段地址:偏移地址 "字符")


试验任务
1.使用debug,将上面的程序段写入内存,逐条执行,观察每条指令执行后,cpu中相关寄存器中内容的变化
可以使用 e 指令 和 a 指令修改,用e也就是机器码编程太傻了,还是用a汇编编程
cpu如何区分指令和数据
机器码	汇编指令
b8 20 4e	mov ax,4e20
05 16 14	add ax,1416
bb 00 20	mov ax,2000
01 d8	add ax,bx
89 c3	mov bx,ax
01 d8	add ax,bx
b8 1a 00	mov ax,001a
bb 26 00 	mov ax,0026
00 d8	add al,bl
00 dc	add ah,bl
00 c7	add bh,al
d4 00	mov ah,0
00 d8	add al,bl
04 9c	add al,9c

2.将下面3条指令写入 从2000:0 开始的单元内存中,利用着3条指令计算2的8次方.  可以这样算2^10是1024,2^9是512少乘以2,所以2^8是256
mov ax,1
add ax,ax
jmp 2000:3

3.向内存中 从b8100 开始的内存单元中填写数据(这个地方是显存的地址)
-e b810:0
01 01 02 02 03 03 04 04

4.查看内存中的内容
pc机主板上的rom中写有一个生产日期,在内存fff00~fffff的某几个单元中
请找出这个生产日期并试图修改它
dos系统,这里是rom内存是不允许写入东西的,以前讲过,rom是开机时候读取的内存,只能读,不能改!


总结承上启下
这章我们学了寄存器
数据寄存器	
地址寄存器	
标志位寄存器	以后讲

数据寄存器有
ax
bx	也可以被当作为 偏移地址寄存器
cx	cx也有其他作用
dx	ax,dx用来处理数据的
也成为通用寄存器
都是16位寄存器,可以各自分割为2个互相独立的8位寄存器
编译器, 为了保证 数据与寄存器之间的 位数一致性 编译器是通过寄存器的位数来判断
所有指令的前提是都要保证数据或寄存器的一致性
mov	移动指令
add	运算指令
它们在运算时可能会 超过 寄存器的 表示最大值  超过的这一部分存放到其他地方去了
寄存器之间时互相独立的

地址寄存器
段地址寄存器 : 便宜地址寄存器	组合规则 组合起来
ds		sp	段地址*16 + 偏移地址 = 物理地址
es		bp	因为时8086cpu 有20根地址线,
ss		si
cs		di
		ip
		bx

cpu 时如何区分指令和数据的
cs:ip这两个寄存器
在任意时刻cpu将 段地址寄存器cs 和 便宜地址寄存器ip 所组合起来的地址 从中读取的内容
全部当作 指令来 执行
指令是有长度的 跟ip寄存器有关
可以修改cs ip这两个寄存器的指令
转移指令
jmp	2000:0
jmp	寄存器格式 (放到ip中,类似于 mov ip,ax 虽然是不能这么做的)

call	xxxxxx 指令执行的过程 ->改变的ip保存了起来也即是保存了步骤2的ip 跳转
1.cpu从cs:ip 所指向的内存单元读取指令, 存放到指令缓存器中
2.ip = ip + 所读指令的长度,从而指向 下一条指令
3.执行指令缓存器中的内容,回到步骤1
改变的ip保存到内存中(下一章讲)
寄存器(访问呢内存)就是讲解这个问题 可以推理出来的东西 除了cs寄存器地方存的

指令和数据存放在内存中是没有任何区别的
是我们汇编程序员 通过修改寄存器中的内容也就是地址寄存器, 告诉cpu数据在哪里,指令在哪里


第三章,寄存器(内存的访问)
前几章遗留的问题
call指令将ip(如:000b)存放到哪里去了(内存的哪里) ret可以拿回
数据长度
字节型数据 = 1B
字型数据 = 2B
在内存中排列
	高位字节:如ah
	低位字节:如al
一个字型数据 存放在内存中 可以由 2个连续的地址单元组成
高地址 内存单元存放 字节型数据的 高位字节
低地址 内存单元存放 字节型数据的 低位字节
如mov ax,1a2b 存放到内存中的是 2b 1a 而他们所对应的地址是如:2b=01 1a=02(16进制)


练习
字节数据 字型数据
内存地址去访问内存 8086cpu 段地址和偏移地址
使用ds段地址寄存器 访问数据用的 c的数组原理就是这么来的
mov al,ds:[0]	mov移动指令 cpu中的al寄存器,内存地址(段地址:[偏移地址]) 意思是将段地址和偏移地址进行组合得到的物理地址
mov al,ds:[1]	中括号[]的意思是得到物理地址里面的内容
mov al,ds:[2]	cpu读取了多长的数据? 一个字节因为案al是8位寄存器
mov al,ds:[3]	但是在debug不允许这么写,要写成mov al,[0]
mov bx,1000	在debug不能mov ds,1000这么写,
mov ds,bx 	r ds可以修改,但是,他不是汇编指令,是debug工具提供的模拟功能,指令是和汇编相关的
mov ax,ds:[0]	cpu读取了一个字型数据,因为是一个字型数据
mov ax,ds:[1]
mov ax,ds:[2]
mov ax,ds:[3]
mov ds:[0],ax	反过来了,同理	
mov ds:[1],ax
mov ds:[0],al
mov ds:[1],ah


练习2
写出下面的指令后 寄存器ax,bx,cx中的值
mov ax,1000	确定了段地址,经过寄存器来判断是字型还是字节型数据
mov ds,ax 	物理地址	内容
mov ax,ds:[0]	10000	23	[0] = 1123 ax=1123
mov bx,ds:[2]	10001	11	[1] = 2211 cx=2211
mov cx,ds:[1]	10002	22	[2] = 6622 bx=6622
add dx,ds:[1]	10003	66
add cx,ds:[2]
不论是移动还是运算,首先要确定数据的长度,通过寄存器来确定

写出下面的指令执行后 内存中 的值
mov ax,1000
mov ds,ax		段地址
mov ax,2c34	物理地址	内容	ax=2c34
mov ds:[0],ax	10000	22   34
mov bx,ds:[0]	10001	11   2c	dx=2c34
sub bx,ds:[2]	10002	22   12	dx=2c34-1122=1b12
mov ds:[2],bx	10003	11   1b

数据段 变成时候一种数据安排
mov ax,123b
mov ds,ax
mov al,0
add al,ds:[0]
add al,ds:[1]
add al,ds:[2]

mov ax,123b
mov ds,ax
mov ax,0
add ax,ds:[0]
add ax,ds:[2]
add ax,ds:[4]


与这章的前面几节小结
字节型数据 字型数据 在内存中的存放
字型数据 在内存中存储时,需要两个地址连续的内存单元存放
高位字节 存放到 高地址中
低位字节 存放到 低地址中

mov add sub 实验
数据的长度 内存中的排列不同 如
字节型数据是 01
字型数据是 01 00

ds 段地址寄存器 也可以说 数据段地址寄存器
cs 指令有关
其他和数据有关

指令和数据在内存中是没有任何区别的 ds:[0] ds[1]读写都学了 也可以把寄存器中的数据保存起来 也可以把寄存器中的数据保存到某个地方去,因为指令和数据在内存中是没有区别的
以后编程的时候慢慢学

写的命令格式,别死记硬背
mov 寄存器,数据		mov ax,1
mov 寄存器,寄存器		mov ax,bx
mov 寄存器,内存单元		mov bx,ds:[0]
mov 内存单元,寄存器		mov ds:[1],cx
mov 段寄存器,寄存器		mov ds,dx
add 寄存器,数据		add ax,1a
add 寄存器,寄存器		add bx,cx
add 寄存器,内存单元		add cx,ds:[2]
add 内存单元,寄存器		add ds:[3],dx
sub 寄存器,数据		sub ax,2b
sub 寄存器,寄存器		sub bx,cx
sub 寄存器,内存单元		sub cx,ds:[4]
sub 内存单元,寄存器		sub ds:[5],dx

有debug这个工具,当你想用某中格式的指令,去debug中尝试
cs:ip 指令从哪里来
ds 数据从哪里来
修改寄存器中的内容去控制cpu 控制整个计算机 读取一个字节 读取一个字


监测点3.1
在debug中,用d 0:0 1f 查看内存
下面的指令执行前 ax=0 bx=0 写出每条汇编指令执行完后相关寄存器中的值
cpu和内存中间的交互
注意数据从哪里来 内存地址
数据的长度 字节型数据还是字型数据
寄存器是互相独立的
-d 1:0地址是
0   1   2   3   4   5   6   7   8  9   a   b  c  d   e  f
08 00 70 00 60 10 00 f0 60 10 00 f0 60 10 00 f0
mov ax,1
mov ds,ax		确定了内存你地址中的物理地址0001:0000 = 0000:0010
mov ax,ds:[0]	字型数据   ax=0008
mov bx,ds:[1]	bx=7000
mov ax,bx		ax=7000
mov ax,ds:[0]	ax=0008
mov bx,ds:[2]	bx=0070
add ax,bx		ax=0078
add ax,ds:[4]	ax=1060
mov ax,0		ax=0
mov al,ds:[2]	字节型数据   al=70
mov bx,0		bx=0
mov bl,ds:[c]	bl=60
add al,bl		al=d0

内存中的情况如下 
CS = 2000H 
		IP = 0 
				DS = 1000H 
						AX = 0		 BX =	0

物理地址 				物理地址
10000H 	B8	mov ax,2000H	20000H	B8	mov ax,6622H	
10001H	00			20001H	22	
10002H	20			20002H	66
10003H	8E	mov ds,ax		20003H	EA	jmp 0FF0:0100H
10004H	D8			20004H	00	
10005H	A1	mov ax,[0008]	20005H	01
10006H	08			20006H	F0
10007H	00			20007H	0F
10008H	A1	mov ax,[0002]	20008H	89	mov bx,ax
10009H	02			20009H	C3
1000AH	00			2000AH
写出cpu执行指令的序列(汇编指令写出)
jmp 1000:0
cs:ip 
mov ax,6622H
jmp 0FF0:0100H
mov ax,2000H
mov ds,ax
mov ax,[0008]
mov ax,[0002]

写出cpu执行每条指令后,cs:ip和相关寄存器中的数值 
从cs:ip 所指向的内存单元读取指令, 指令存放到指令缓存器中
ip = ip+所读指令的长度 字节数
执行指令缓存器中的内容,回到第一步
ax 6622 2000 c389 ea66
bx 
cs 2000 2000 1000 1000 1000 1000(只用写步骤2 的ip地址)
ip 3       8      3       5       8      b
ds 2000 2000

再次体会数据和指令之间有区别吗?如何确定内存中的信息那些是数据,那些是指令?
没有区别,在cs:ip中读取的是指令,在ds:[偏移地址]中读取的是数据
汇编指令去修改寄存器中的内容 数据从哪里来 指令从哪里来


栈的概念
栈是一段连续的内存单元,也就是一段连续的内存地址
为什么起一个非常专业的名字呢?
特殊在他的访问形式上
mov 移动指令 区别最大的地方
mov ax,1000
mov ds,ax
mov ax,ds:[0]
mov ax,ds:[1]
要有怀疑和实践的精神前面所学反驳

前几章遗留的问题
call指令将ip(如:000b)存放到哪里去了(内存的哪里) ret可以拿回
通过程序的角度去看栈
最后入栈的数据一定会放到栈顶
我们可以为栈顶的最上面的数据的位置做一个标记
标记代表了箱子中最上面的数据在栈中的位置
出栈肯定是箱子中最上面的数据拿走,然后栈顶标记指向下一个位置的
术语 栈顶标记 栈 入栈 出栈
由于不断的入栈 或者 出栈我们需要不断的修改栈顶标记 来确定栈中最上面的数据 在栈中的位置

内存的角度将栈的概念
入栈 push	将16位寄存器 或者 内存中的 字型数据 -> 栈顶标记标记的上面 修改栈顶标记
出栈 pop	将栈顶标记 所标识 的 字型数据 -> 16位寄存器 或者 内存中 修改栈顶标记

存放数据的
数据从哪里来 寄存器中 内存中
数据的长度 字节型数据 字型数据? 是字型数据,只能用字型数据,用al bh是不行的
栈顶标记在 入栈和出栈时 所扮演的角色去 理解这个问题

入栈时 决定了 你放的数据的存放位置(内存地址) -> 栈顶标记的上面 修改栈顶标记
出栈时 决定了 你拿走数据的位置(内存地址) -> 修改栈顶标记
来确定栈中最上面的数据 在栈中的位置(内存地址)
栈顶标记 是 内存地址 = 段地址 和 偏移地址来表示
在8086cpu中 在任意时刻 将 段地址寄存器ss 和 偏移地址寄存器 sp 所组合起来的地址 当作栈顶标记
push ax	修改sp寄存器中的数据sp=sp-2, 为什么-2,因为一个字型是2个字节长度
	将ax中字型数据 -> ss:sp所组合处理啊的内存地址中 入栈
pop bx	ss:sp所组合出来的内存地址 中的 字型数据 -> bx
	修改栈顶标记 sp = sp+2 成为新的栈顶标记 出栈, 同理+2是弹出,弹出1个字型长度一个所以+2
数据从哪里来 寄存器中 内存中
数据的长度 字型数据
mov ax,2233
push ax
pop bx
得到的是 ax=2233 ss:(sp-2)=33 22 bx=2233

在实验的时候如果改变了bp si di寄存器中的数据,也会改变栈中的数据, 这要后面讲,因为我们现在缺少解决问题想法的基础

在8086cpu中 在任意时刻 将 段地址寄存器ss 和 偏移地址寄存器 sp 所组合起来的地址 当作栈顶标记
栈在哪里是我决定的,容量大小也是我决定的
在之前我们决定cs:ip是cpu从哪里读取指令
是可以用转移指令去修改
所以我们也可以决定栈顶标记在哪里,栈在哪里,栈的大小
假设sp = 10H
16B = 8字节数据 push可以操作8次
起始地址+你所设定的栈的大小的 字节数
0000 + 16(10H) = 10H
ss:sp所组合出来的栈顶标记
mov ax,2000
mov ss,ax
mov sp,10
mov ax,2233
push ax
push ax
push ax
pop bx
pop cx
pop dx
在设置ss寄存器的时候会立即执行下一步就可以了,连续执行是为了控制栈段大小,防止程序调用时出错
讲了,栈时如何设置的 最好设置成16的倍数,自己的一个约定,放置一些 稀奇古怪的 问题出现

栈的越界问题
mov ax,2000
mov ss,ax
mov sp,8
mov ax,2233
push ax
push ax
push ax
push ax
push ax
最后我们看到sp=fffe了,超出了栈,栈溢出了,有可能会覆盖掉fffe这个位置上的关键数据或者指令,导致了程序无法启动
其他地方可能存放着指令或者数据由于一直push或者pop破坏了这个栈,从而导致了一连串的错误
有没有 栈的上限 或者 下限的 寄存器 来确定栈的大小来帮助我们判断一下从而就不会栈的越界问题?
实际的情况是8086cpu在任意情况是将 段地址寄存器ss 和 偏移地址寄存器 sp 所组合起来的地址 当作栈顶标记,所以是没有的
所以我们在编程的时候一定要小心栈的操作,要根据可能用到的栈的最大空间去安排栈的大小,从而去避免栈顶的越界问题

栈的极限大小,因push和pop影响的是sp寄存器,所以也可以问成sp的寄存器的变化范围是多少
sp的寄存器的变化范围, 0~ffffH 要除以2,因为65536是字节,而我们要存的是字型数据,所以是32768
假设ss=2000 sp=? 已知sp要取最大值,然后每次push运行前都需要-2,所以要ffff+2?是吗,答案是0,因为,最好是16的倍数,并且这是一个环形栈
就是设置一个可以存放32768个字型数据的栈 一共65536个字节=64K
sp如果超出了,也就是栈顶的越界, 覆盖了原来栈中的内容

栈的作用
前几章遗留的问题
call指令将ip(如:000b)存放到哪里去了(内存的哪里) ret可以拿回
临时性保存数据,知道了可以保存call存放的指令了
就是如果我们在call外设置了ax,bx这些数据寄存器了,然后再call里又设置了ax,bx这些数据寄存器,的话当call执行完,想用外边的数据寄存器里的数据就已经发生改变.所以我们要用到栈,再改变前需要将数据寄存器中的数据放到栈中(push),想要拿回之前的数据(pop)就可以得到改变前的数据了

mov ax,1000
mov bx,2000
push ax
push bx 注意入栈顺序
mov ax,0
mov bx,0
pop bx
pop ax 注意出栈顺序

mov ax,1122
mov bx,3344
push ax
push bx
pop ax 注意这里是写反了,也就是交换了
pop bx

内存也是一样的
mov ax,1000
mov ds,ax
push ds:[0]
push ds:[2]
pop ds:[0]
pop ds:[2]
栈的操作本质上就是一种mov移动指令,通过ss:sp
笔记的记录方式,是不是也是一种栈,栈是一种非常重要的机制

补全指令,将1000~100F 8个字型数据逆序复制到2000~200f
mov ax,1000
mov ds,1000 ds=1000
 mov ax,2000
 mov ss,ax
 mov sp,10
push ds:[0] 1000*10+0 字型数据,存入ss:sp栈中
push ds:[2] sp -= 2
push ds:[4] 2000E+2=20010(栈的起始指针)
push ds:[6]
push ds:[8]
push ds:[a]
push ds:[c]
push ds:[e]
组合成 20010 ss×10+sp = 20010

补全指令,将1000~100F 8个字型数据逆序复制到2000~200f (结果一样就行)
mov ax,2000
mov ds,ax ds=2000
 mov ax,1000
 mov ss,ax
 mov sp,0
pop ds:[e] 2000×10+e 2000e字型数据, 栈中字型数据ds:[e]
pop ds:[c] 将字型数据->ds:[e] sp += 2
pop ds:[a]
pop ds:[8]
pop ds:[6]
pop ds:[4]
pop ds:[2]
pop ds:[0]

实验任务
根据debug,将下面的程序段写入内存,逐条执行,根据执行后的实际运行情况天空
mov ax,ffff
mov ds,ax
mov ax,2200
mov ss,ax
mov sp,100
mov ax,ds:[0]	ax=c0ea
add ax,ds:[2]	ax= c0fc=c0ea+0012
mov bx,ds:[4]	bx=30f0
add bx,ds:[6]	bx= 6021=30f0+2f31
push ax		sp=(fe)修改内存单元的地址是(ss:fe)内容为(c0fc)100-2=fe
push bx		sp=(fc)修改内存单元的地址是(ss:fc)内容为(6021)
pop ax		sp=(fe) ax=(6021)
pop bx		sp=(100) bx=(c0fc)
push ds:[4]	sp=(fe)修改内存单元的地址是(ss:fe)内容为(30f0)
push ds:[6]	sp=(fc)修改内存单元的地址是(ss:fc)内容为(2f31)

仔细观察实验过程,然后分析,为什么2000:0~2000:f中的内容会发生变化
mov ax,2000
mov ss,ax
mov sp,10
mov ax,3123
push ax
mov ax,3366
push ax
结论,一开始我们看栈的地址是没有数据的,执行一步操作之后便有了数据,这些数据的含义是从栈顶往下说,第一个字型数据不是寄存器里的以后会讲到,第二个字型数据是cs寄存器里的内容,第三个字型数据是ip寄存器里的内容,第四个字型数据是bp寄存器里的内容,第五个字型数据是ax寄存器里的内容,都保存在栈中
保存在栈中 每执行一条t指令 就会 将寄存器保存到栈中 栈是临时性保存数据
指令call 会将下一条指令的ip保存到栈中,目的是为了ret指令可以从栈中拿回
要从设计者的角度 去想这个问题(好像bp寄存器记录着入栈前sp状态,方便mov sp,bp 恢复)


承上启下 两章
我们在一段内存中 存放数据 数据段 存放了我们自己定义的数据 -e
我们在一段内存中 存放指令 指令段(代码段汇编代码) 存放了我们自己定义的指令 -a
我们将一段内存定义成栈空间 因为我们处理数据的时候需要临时性的存放 称为栈段

我们如何让cpu按照我们的安排去访问这些内存段呢?
对于数据段来说,段地址->ds寄存器,偏移地址目前只学过[0],[1],[2]... 可以用mov add sub 指令去访问这些内存单元
那么cpu就会将我们定义的数据段中的内容 当作数据来访问,就是自己弄个ds数据段出来,然后自己用偏移地址去访问

对于代码段来说,我们可以修改cs:ip这两个寄存器去指向我们定义的代码段
这样cpu就将执行我们定义的代码段中的指令
用jmp指令可以修改ip寄存器中的内容,这样cpu就执行了 我们定义代码段中的指令

对于栈段来说,我们可以修改ss:sp这两个寄存器去决定栈顶标记在哪里
这样cpu在执行栈的操作时 比如 push pop 就会将 我们定义的 栈段 当作 栈空间使用
进行临时性的数据存放或者取出

不管我们如何安排,cpu将内存中 某段内容当作指令,是因为cs:ip指向哪里
cpu将某段内存当作栈空间,是因为ss:sp指向哪里

所以我们编程的时候一定要清楚, 我们时如何安排内存的,以及如何让cpu按照我们的安排去干事
数据从哪里来,指令从哪里来,临时性的数据 存放到那里去
取决于 我们对cpu中的 地址寄存器的设置 cs ip ss sp ds寄存器的设置

内存段的安全问题 要自定义数据段,代码段,栈段
随意的向某一空间 写入内容是非常危险的
mov指令 由于我们不小心修改了 系统中存放在 内存中的 重要 数据 或者 指令 导致的 程序的崩溃 系统的崩溃
向安全的内存空间去写入内容
0:200~0:2ff是安全的,但是太小了
或者就是使用操作系统分配给你的内存空间
在操作系统的环境中,合法的通过操作系统取得的内存空间 都是安全的
因为操作系统不会让一个程序 所使用的内存空间 和 其他程序 以及系统自己的空间产生冲突
操作系统就是干管理内存的时期的
在操作系统允许的情况下,程序可以取得任意容量的 内存空间 有两种
一种是 系统加载程序时 位程序分配的内存空间 (c中的malloc)
一种是 程序在执行的过程中向系统再去申请内存 (c中realloc 但不会讲,因为会牵扯到一些东西)

如何在系统运行程序的 如何运行软件 是exe文件 而exe文件是个程序 由系统运行 为程序分配内存
编译和连接得到的是一个exe文件
源文件 安排自己的代码段 数据段 栈段 编译和连接 得到一个exe文件
如何从系统申请内存,就是得到exe文件
我们以后对源文件 进行编译和连接 就可以得到exe文件,系统会执行exe文件 然后这些都是安全的,所以我们将代码段 数据段 栈段都是写到源文件中的

我们以后的源文件会用到伪指令
告诉编译器 这里怎么翻译 那里怎么翻译
对cpu的地址寄存器 进行了 设置 从而让cpu按照我们的安排去访问 数据段和栈段
至于代码段cs:ip设置 指令从那开始是关于start的关键字的

耐心和一些细心的思考
回头看一遍 初学者的
要从设计者的角度去思考去观察
利用好debug工具遇到疑惑的话
最好要跳出设置的思维框框
内存分为 代码段 数据段 栈段 ,但有的人认为还有堆段(个人认为的)
指令和数据混合在一起为了解决实际问题 工程的问题
不要去禁锢自己的想法 要在debug中尝试一下 编程 写个小的程序 去 测试一下自己的想法 只要符合规则就可以了

这章最后的补充
系统分配给我们内存 好想要牵涉高深的知识,但并不牵涉
其实系统给我们程序内存 exe文件就是系统分配内存的过程
操作系统可以理解为管理内存的程序 占用内存 专门是分配内存
编译和链接exe文件然后运行,这就是个分配的过程,源文件也在里头 平时使用的经验


为什么需要编译和链接
编译(masm) .asm -> .obj
链接(link) .obj -> .exe
代码少会很快,但是代码多了可能会编译更长时间
代码是有错误的 去修改 几行代码 如果一个是大的代码量来说 总不能从头开始编译把
所以编译时先把源文件拆分开来然后再编译成多个obj文件 其次通过链接把所有的obj文件连接在一起 最后得到最终的exe文件
我们只会写个asm文件 知道这么一个概念

exe文件
通过链接(link)最后得到这个exe文件 如果要运行exe文件时系统会分配给他一段内存
系统时怎么知道 要分配多大的内存 给 这个程序的? 也就是这个exe文件
因为exe文件中除了我们中各程序的代码 还包括了一些信息
这些信息包括了 文件有多大 程序放在哪里
这些信息被称为描述信息 系统就是根据这些描述信息对寄存器进行相关的设置
start伪指令 是告诉编译器 strart伪指令 再exe文件的描述信息中扮演什么角色?
就是将我们设置的 程序的入口地址 在哪里 记录再exe文件的描述信息中 然后系统通过这个描述文件中的内容 去设置cs:ip然后还有一些其他内存
可描述信息 exe可执行文件 不止包括了 我们整个程序 还包括了 描述信息 系统是根据这些描述信息 进行相关设置的

源代码文件asm 汇编语言
汇编指令	被编译器翻译成 0101010 机器指令 机器码 由cpu执行的
伪指令	由编译器执行的
符号体系	由编译器执行的
设置的依据 现不需对assume要深入了解 为了编程
成对出现的
data segment 告诉了编译器data段从这里开始
data ends  告诉了编译器data段从这里结束 分配内存
段的名字可以随意取,方便阅读
最后会有个end指令,告诉编译器这个程序就结束了
add sub汇编指令 和 +-*/符号体系是由区别的,但这个乘法在汇编语言中肯定有对应的汇编指令的
我们知道系统在加载程序的时候 给程序分配内存 设置寄存器 
int 21H 程序返回的功能 是只要程序执行到这里就会将内存和寄存器都还给系统,不可能永远占用内存的,因为内存是有限的,直到最终系统没有内存可用,所以我们需要程序返回告诉系统这块内存又可以使用了

程序的跟踪debug+程序名
cx寄存器 = 程序的长度
p执行 int指令 会结束这个exe程序之后按q退出
psp区 从ds:0开始到256个字节 开头是我们程序的名字
系统加载程序到内存中 它是用来 系统和程序之间 进行的通信

1.将下列程序保存为t1.asm文件,将其生成t1.exe
asssume cs:code
code segment
	mov ax,2000
	mov ss,ax
	mov sp,0
	add sp,10
	pop ax	sp=12
	pop bx	sp=14
	push ax	sp=12
	push bx	sp=10 改变了栈中原有数据互换了
	pop ax	sp=12
	pop bx	sp=14 然后又把寄存器中的值给换了下
	mov ax,4c00
	int 21
eode ends
end

后面的课程要完成一个小目标 实验7
这是第一个对我学习成果的一个测试
首先是psp区,是ds:0向下256字节是程序和系统之间通信的
然后要利用好栈段,数据段,代码段如何去安排这些内存段 然后安排cpu按照我们的安排去做

这大章最少掌握的内容和一些编译规则
快速编译 也就是类似于t1.exe(当时自己写的文档)
编译上的错误 语法问题
逻辑上的错误 bug
翻译软件的规则
1.mov ax,b800 在写代码的时候要在前面字母加上0->0b800 任何字母数据之前都要加上0
2.10和10H的区别,就是十进制和十六进制的区别,在十六进制中一个是a一个是10
3.注释 ;注释 分号就是注释符号,;和//作用和用法都是一样的

exe和系统分配内存重要的概念
;exe被系统启动 事实上就是分配内存的过程 安全的内存 描述信息知道你要多大内存
;操作系统是管理内存的 系统就要分配给程序内存
;源文件中安排自己的代码 自己的数据 自己的栈 通过编译分成多个asm文件然后再把asm编译成obj文件,然后链接把多个obj文件连接再一块组成exe文件


内存的访问方式[bx]代替[0]
数据从哪里来 ds:[0] ds:[1]
数据的长度 字节 字型 现在还没有自己定义数据段 编程 偏移地址寄存器 bx
	;mov ax,ds:[0]
	;mov bl,ds:[0]	
;假设是我们自己定义的数据段 都是字型数据  
	mov bx,0
	mov ax,ds:[bx]
	add bx,2
	mov ax,ds:[bx]
	add bx,2
	mov ax,ds:[bx]	;和数组类似	
;假设10H是我们自己定义的数据段 字节型数据 从10H开始
	mov bx,10H
	mov al,ds:[bx]
	add bx,1
	mov al,ds:[bx]		
	add bx,1
	mov al,ds:[bx]

[bx]的问题
程序和内存中的情况如下图所示,写出程序执行后,21000H~21007H 内存单元中的内容
新的指令inc是increase的简写是增加的意思将dx中的值加1,说白了就是c中的++运算,相比add节约内存还有后面要学的
21000H be
21001H 00
21002H 00
21003H 00
21004H 00
21005H 00
21006H 00
21007H 00

mov ax,2000H
mov ds,ax
mov bx,1000H
mov dl,0eh
mov ds:[bx], dl
mov ax,ds:[bx]
inc bx
inc bx
mov ds:[bx],ax
inc bx
inc bx
mov ds:[bx],ax
inc bx
mov ds:[bx],al
inc bx
mov ds:[bx],al
偏移的思想 比如 1000+0 1000+1....
我们是如何安排内存的

loop指令
假设 我们要向 2000H:1000H 这里开始填写0123456789abcdef 这些字节数据,通过编程应该怎么做
mov ax,2000H
mov ds,ax
mov bx,1000H
mov dl,0

mov ds:[bx],dl
inc dl
inc bx

mov ds:[bx],dl
inc dl
inc bx
......一共16个(笨办法)
有什莫指令可以不用复制重复的指令呢
接近的办法 我们要不断的执行那3条指令?执行16次(除了look要讲的指令)
我们如何让cpu不断的执行这3条指令? 可以使用jmp去修改cpu中IP寄存器的值就可以了
但是再源文件中不能 jmp 000aH 这样写的,再debug可以这样写 所以在inc bx的下一个ip地址写上jmp 000a就行了,但是一个死循环
那再源文件中如何写呢? 
jmp setNumber ;标号(内存地址) 标识 jmp 000aH,也就是setNumber=000aH, 然后再把标号添加到要跳转到的地方 如下(有点像c的goto语句)
setNumber:	mov ds:[bx],dl
		inc dl
		inc bx
		jmp setNumber
为什么不是之前的000a地址呢?因为你在前面写东西地址肯定会跟着你写的内容发生变化,这样写的灵活

loop指令 循环指令 可以当作跳转(jmp)指令只不过是按照次数来跳转
循环次数 跳转次数 保存在cx寄存器中
loop的用法和jmp非常相似,只不过循环外要设置好cx值
		mov cx,16
setNumber:	mov ds:[bx],dl
		inc dl
		inc bx
		loop setNumber
loop指令执行的时候分为2个步骤
1.cx=cx-1
2.判断cx中的值,不为0则跳转到(jmp)到 标号(内存地址)位置,继续执行等于0则执行下面的指令
如果cx一开始就是1的话,看起来不会循环,但已经循环一次了,但结果和没循或者说直接执行一样
如果cx设置称为0 了,会将cx中的值-1,所以是ffff,因为越界了,所以尽量设置成大于0的

编程题
用编程进行加法计算123*236结果放在ax中
loop后面的名字要有意义,但也不能是关键字
		mov ax,0
		mov cx,123
setNumber:	add ax,236
		loop setNumber

		mov ax,4C00H
		int 21H

用编程求ffff:0到ffff:f字节型数据的和,结果放在dx中
学到了 阅读性 初始化 数据从哪里来 以后还会有数据放到那里去
		mov dx,0
		mov ax,0ffffH
		mov ds,ax
		mov bx,0	;阅读性 初始化 数据从哪里来 以后还会有数据放到那里去
		mov cx,16
		mov ax,0
		
sumNuber:	mov al,ds:[bx]
		add dx,ax
		inc bx
		loop sumNuber
		
		mov ax,4C00H
		int 21H

将内存ffff:0~ffff:f 内存单元中的数据复制到0:200~0:20f中
mov ax:[dx],ds:[bx]这样写是不行的,小提示,可以用栈,但是如果你没有设置栈段的话,用栈有点危险,可以每次loop开始的时候mov ax,0ffffH,这样不会用到栈了
		mov ax,0
		mov bx,0
		mov cx,16
		mov dx,0
		
		mov ax,0ffffH
		mov ds,ax

copyNumber:	push ds
		mov dh,ds:[bx]
		mov ax,20H
		mov ds,ax
		mov ds:[bx],dh
		pop ds
		inc bx
		loop copyNumber

		mov ax,4C00H
		int 21H
告诉一个寄存器,es寄存器
es寄存器和数据相关
ds代表数据从哪里来
es代表数据到哪里去
指令中不断的去设置段地址寄存器其实是很浪费cpu的操作,上面的就是浪费cpu的操作
逻辑非常清楚 数据从哪里来,到哪里去
		mov ax,0ffffH
		mov ds,ax
		mov ax,20H
		mov es,ax
		mov cx,16
		mov bx,0

copyNumber:	mov dh,ds:[bx]
		mov es:[bx],dh
		inc bx
		loop copyNumber

		mov ax,4C00H
		int 21H
优化的地方是,提示在c中的循环语句中,让数据数据主动找循环次数.或者说把dh改成dx然后循环8次每次add bx,2,唯一的缺点就是cx=0的时候就不循环了
		mov ax,0ffffH
		mov ds,ax
		mov ax,20H
		mov es,ax
		mov cx,8
		mov bx,0

		mov dx,ds:[bx]
		mov es:[bx],dx
		mov bx,0

copyNumber:	mov bx,0
		add bx,cx
		add bx,cx
		mov dx,ds:[bx]
		mov es:[bx],dx		
		loop copyNumber

		mov ax,4C00H
		int 21H
老师写的简单易懂,还有用到栈的直接移动过去push和pop连寄存器都节省了
		mov ax,0ffffH
		mov ds,ax
		mov ax,20H
		mov es,ax
		mov cx,8
		mov bx,0

copyNumber:	mov dx,ds:[bx]
		mov es:[bx],dx
		add bx,2
		loop copyNumber

		mov ax,4C00H
		int 21H
尽可能把所学的东西用上,先实现功能然后再慢慢的修改
先将代码保存起来 灵感了 去修改一下 编程能力 就会越来越强

实验题
1.编程, 向内存0:200~0:23f 依次传送数据0~63(3fh) 一共64个字节型数据,为什么是字节型,因为他不是400H或者3f0H懂?
程序中只能使用9条指令,包括程序返回语句
		mov ax,20H
		mov ds,ax
		mov cx,64
		mov bx,0
		
setNumber:	mov ds:[bx],bl
		inc bx
		loop setNumber
		
		mov ax,4C00H
		int 21H

2.下面的程序的功能是将"mov ax,4c00H"之前的指令复制到内存 0:200处,补全程序.上机调试,跟踪运行结果.
意思就是把xxx之前的指令也就是从cs开始的复制到20:0处,复制多少就看自己写的代码有多少楼
assume cs:code
code segment
		mov ax,(cs)
		mov ds,ax
		mov ax,0020H
		mov es,ax
		mov bx,0
		mov cx,(23)	;复制多少字节,这要看自己写的程序有多少字节了,记住一定要看自己的程序
		
s:		mov al,ds:[bx]	;数据从哪里来
		mov es:[bx],al
		inc bx
		loop s
		
		mov ax,4c00H
		int 21

本章小结
就是讲了,通过bx偏移地址寄存器去修改里面的内容去实现在以前debug中这mov ds:[0],ax去访问一段连续的内存
我们在文件中用bx去访问内存,还可以修改bx中的值
当我们知道有些指令是重复的,非常浪费内存然后通过jmp和loop指令
jmp指令,修改ip寄存器里的内容,没有次数限制,相当于死循环
loop指令其实和jmp指令都是一样的,都是跳转指令,只不过有次数限制,根据cx寄存器来
mov ax,2000
mov ds,ax    ;在这是设置段地址寄存器是非常不安全的,是访问一段连续的内存
下一大章将的是系统分配给我们的内存
自己去设置数据段,栈段,这样是安全的,不会产生一些奇怪的问题


在代码段中安排自己定义的数据
考虑这样一个问题,编程计算下面8个 字型数据 结果存在 ax寄存器中
1,2,3,4,5,6,7,8
安排一个连续的内存中 loop指令 add ax,ds:[bx] add bx,2
以前是用e指令去修改 一段内存的,是不安全的
安全的是系统分配给我们的
如何安排我们自己定义的指令
程序加载过程中事实上就是系统分配给 程序内存的 过程
所以只要把数据写在源文件中就可以了
是dw指令,define(定义) word(一个字[就是字型数据])的简写
dw 1,2,3,4,5,6,7,8
这样写对吗(没写start时),答案是不对的,因为你把指令和数据写在一起了,在内存中,指令和数据是没有区别的,所以要用到start伪指令用来让指令从哪开始执行
		dw 1,2,3,4,5,6,7,8	我们自己定义的数据,不是我们自己定义的指令

start:		mov ax,0	但是结尾也要加start才行
		mov bx,0
		mov cx,8

addNumber:	add ax,cs:[bx]
		add bx,2
		loop addNumber		


		mov ax,4C00H
		int 21H
code ends
end start	结尾要加start
如果不用start呢,用jmp指令,开始跳转到指令开始的地方,要修改这个位置,因为前面加了指令后面的地址会改变,所以一半都是用start伪指令
		jmp play

		dw 1,2,3,4,5,6,7,8		

play:		mov ax,0
		mov bx,3	要修改这个位置,因为前面加了指令后面的地址会改变,所以一半都是用start伪指令
		mov cx,8

addNumber:	add ax,cs:[bx]
		add bx,2
		loop addNumber		

		mov ax,4C00H
		int 21H

code ends
end

在代码段中安排自己定义的栈空间
完成下面的程序,利用栈 将程序中定义的数据逆序存放
assume cs:code

		dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H	;如何看待内存的,那里是数据 哪里是指令
		;那里是栈,我们该怎么做,通过设置ss和sp就可以了,我们先设置一段数据,然后再把这一段空间当作栈就可以了
		dw 0,0,0,0,0,0,0,0	;dw存放注意这个是字型数据,也就是32个字节数据 
		dw 0,0,0,0,0,0,0,0

start:		mov ax,cs	;我们不能把栈段地址写固定,因为不同的系统会变,所以要写个和cs一样的段地址
		mov ss,ax
		mov sp,30H
	
		mov bx,0
		mov cx,8

retNumber:	push cs:[bx]
		add bx,2
		loop retNumber	;完成已经入栈,剩下的只要弹出就是逆序的了
		
		mov bx,0
		mov cx,8

popdata:		pop cs:[bx]
		add bx,2
		loop popdata

		mov ax,4c00H
		int 21H

code ends
end
我们以前是在debug中随便找了块内存当做栈空间使用的,而这是不安全的
而我们写在源文件上的会编译成exe文档 在debug的时候,且系统分配给他内存是安全的
耐心的分析内存,那里是数据,哪里是栈,哪里是指令

监测点
下面的程序实现依次用内存0:0~0:15单元中的内容改写程序中的数据 完成程序
assume cs:code

		dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H

start:		mov ax,0
		mov ds,ax
		mov bx,0	;ds=0 bx=0

		mov cx,8

retNumber:	mov ax,ds:[bx]	;ax是16位寄存器
		mov cs:[bx],ax
		add bx,2
		loop retNumber
		
		mov ax,4c00H
		int 21H

code ends
end start

下面的程序实现依次用内存0:0~0:15单元中的内容改写程序中的数据 数据传输用栈来进行,栈空间设置在程序内,完成程序
assume cs:code

		dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H	;内存的分配搞清楚 我们程序的数据
		dw 0,0,0,0,0,0,0,0	;这里16个字节是我们的栈空间

start:		mov ax,0
		mov ds,ax
		mov bx,0	;ds=0 bx=0

		mov ax,cs
		mov ss,ax
		mov sp,20H

		mov cx,8

retNumber:	push ds:[bx]	;ax是16位寄存器
		pop cs:[bx]
		add bx,2
		loop retNumber
		
		mov ax,4c00H
		int 21H

code ends
end start

将数据,代码,栈放入不同段中
我们将这些全部数据段,栈段,代码段放入一个code中显的非常混乱,然后ip不是从0开始的(所以他们呢占用了ip寄存器变化的范围)间接减少指令数量
所以我们要用上伪指令,告诉编译器,这里怎么翻译,哪里怎么翻译
assume cs:code, ds:data, ss:stack	;伪指令,告诉编译器,这里怎么翻译,哪里怎么翻译

data segment
		dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H
data ends

stack segment stack ;这样写stack就不会有stack警告了
		dw 0,0,0,0,0,0,0,0
		dw 0,0,0,0,0,0,0,0
stack ends

code segment
;start是记录了exe文件中的描述信息中
;而系统加载exe文件的时候会根据描述信息中的入口地址在哪里对cs:ip这两个寄存器进行设置

;以后设置数据和栈的时候就非常方便了
;虽然它们的段地址都不一样,但是他们呢的物理地址相差无几,段地址×10+偏移地址=物理地址,自己试试看物理地址是否一样
start:		mov ax,start(cs)
		mov ss,ax
		mov sp,30H

		mov ax,data
		mov ds,ax
	
		mov bx,0
		mov cx,8

retNumber:	push ds:[bx]
		add bx,2
		loop retNumber
		
		mov bx,0
		mov cx,8

popdata:		pop ds:[bx]
		add bx,2
		loop popdata

		mov ax,4c00H
		int 21H

code ends
end start
这样看着代码就不是非常杂了

实验
编写,调试具有多个段的程序 段(segment)的编译(翻译)规则 内存的分布
观察每个段(segment)编译后 实际占多少个字节
assume cs:code, ds:data, ss:stack	
data segment
		dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H
data ends

stack segment stack
		dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:		mov ax,stack
		mov ss,ax
		mov sp,16

		mov ax,data
		mov ds,ax
	
		push ds:[0]
		push ds:[2]
		pop ds:[2]
		pop ds:[0]

		mov ax,4c00H
		int 21H

code ends
end start
问题
cpu执行程序,程序返回前也就是程序执行完之前,data段中的数据为多少?8个字型数据
cpu执行返回前,cs=076c ss=076b ds=076a
设程序加载后code段地址为x,则data段的段地址为x+1: stack段地址为x+2

下面一道题就是上一道题把数据段和栈段中的数据都变成两个
问题
程序返回前,data中数据为多少?4字节2字型
返回前,cs=076c ss=076b ds=076a
加载后,code段为x,data=x+2 stack=x+1
如果段中的数据占n字节,则程序加载后,该实际占有的空间为 n的最小16倍数,向上取整用公式((n%16)+1)*16
最重要的结论,数据 栈段和指令段的数据都是 n/16向上取整 的 最后得到的都是16的倍数 差不多和c中内存对齐一样.

下面一提就是将code移动到了最上面
问题
程序返回前,data中数据为多少?4字节2字型
返回前,cs=076a ss=076e ds=076d
加载后,code段为x,data=x+2 stack=x+1
这节课,一个段(segment)最少占用16个字节其次的都是16的倍数

程序如下,编写code段中的代码,将a段和b段中的数据依次相加,将结果存到c段中

本章小结
如何在系统分配给我们内存
安排自己的数据
安排自己的栈
安排自己的代码
masm(编译) link(链接) exe 文件 系统会根据exe文件中的一些描述信息 进行内存分配
dw是字型数据 db是字节型数据
编译的规则 内存的分配 最小是16,或者16的倍数往上取整 这就是一个段的实际占用空间

灵感,看电脑的一些小文件属性的时候 大小和占用空间是不一样的 占用空间>=大小,最小是4kb(0不算)其次是8KB,14KB
推测,系统为了读取方便,特地怎么做.思想要延伸出去,挖掘思想的潜力 专注编程


and和or指令
先讲一下,更灵活的内存地址定位方法
已知bx一般设置成ds的偏移地址寄存器
我们可以用si和di偏移地址寄存器
这样我们就有了,两个偏移地址寄存器使用了,怎么用? ds:[bx+si] ds:[bx+di]
这样就可以更灵活了,反应了ds:[这里的东西可以做+-运算的]
逻辑运算指令and 和 or
按照二进制位运算的类似c中的&& ||
案例代码如下
assume cs:code, ds:data, ss:stack	
data segment
		dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H
data ends

stack segment stack
		db 128 dup(0)	;128个字节数据,用0写入
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov ax,0
		mov al,00001111B
		and al,11110000B	;与运算 将相对应的位2个为1运算结果才为1,就是c中的&&
		;000000B	;就是将对应的位 设置为0 其它位不变,就是两个都为1为1,其他为0
		
		mov al,00001111B	;或运算 or 将相对应的位 只要有一个是1 那么运算结果就是1
		or al,11110000B	
		;11111111B	;就是将 先对应的位 设置为 1 其他 位不变

		mov ax,4c00H
		int 21H

code ends
end start

以字符形式给出数据
ASCII表 字符 = 符号 是一种图形 有1234... abcd...
ASCII是一张编码表
信源 编码 信道 (噪音) 译码 信宿
用通俗易懂的方式来说
信源:嘴巴,开始的地方
编码:对声波进行编码(大家之间的约定),用同一种编码语言
信道:通过空气传播,通过xxx传播
(噪声):相当于干扰
译码:声音到了你的耳朵中,你知道我在说什么东西
信宿:到了你的大脑里,到了归宿的地方?
开始下面的案例
assume cs:code, ds:data, ss:stack	
data segment
		;db 48,49,50,51,52,53	;因为是符号的编码是字节型,所以写成字节型,这样写行,但是写的麻烦记不住,所以用下面的
		;db 65,66,67,68,69,70
		;db 97,98,99
		db 'hello world'	;用这种方法记得加单引号,比上面的硬写ASCII表好多了吧,说白了就是字符串
		;记住在ASCII表左边是不能被打印出来的也就是控制字符,能打印出来的是打印字符
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov ds,data
		mov bx,0
	
		mov al,'a'	;这样也是可以的,反正要输入字符的话需要加''号才行
		mov al,'b'

		mov ax,4c00H
		int 21H

code ends

end start
下去思考 它的二进制写法 and or 字符 大小写的转换问题
a=91=61H = 0110 0001
A=65=41H = 0100 0001
为什么要这样编码它们之间的关系

字母的大小写转换
先看一组
A	41H	0100 0001
B	42H	0100 0010
C	43H	0100 0011

a	61H	0110 0001
b	62H	0110 0010
c	63H	0110 0011

有个高位地址的左数第3个不一样其他全一样所以要小写->大写要and 1101 1111
同理大写->小写要or 0010 0000
然后有一道编程题
assume cs:code, ds:data, ss:stack	
data segment
		db 'BaSic'		;将第一个字符串转换成大写
		db 'Hello World'	;将第二个字符串转换成小写
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov cx,5
upLetter:		mov al,ds:[bx]
		and al,11011111B
		mov ds:[bx],al
		inc bx
		loop upLetter
	
		mov cx,10
		mov bx,5
lowLetter:		mov al,ds:[bx]
		and al,00100000B
		mov ds:[bx],al
		inc bx
		loop lowLetter

		mov ax,4c00H
		int 21H

code ends

end start
它们编码表的编码目的 就是我们可以有一个更快的运算方式 判断(以后会学) 逻辑运算(&& ||)运行非常快 使得程序更加快
数据的安排

新的一种访问内存单元的的方式
ds:[bx+数字]
然后自己去debug中做小实验去
然后写一段代码,而这段代码就是上一个代码,不过数据段中的数据的长度是一样的
assume cs:code, ds:data, ss:stack	
data segment
		db 'BaSic'	;将第一个字符串转换成大写
		db 'Hello'	;将第二个字符串转换成小写
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov cx,5
upLetter:		mov al,ds:[bx]
		and al,11011111B
		mov ds:[bx],al
		inc bx
		loop upLetter
	
		mov cx,5
		mov bx,5
lowLetter:		mov al,ds:[bx]
		and al,00100000B
		mov ds:[bx],al
		inc bx
		loop lowLetter

		mov ax,4c00H
		int 21H

code ends

end start
但内存分配是非常重要的,要看清楚结构,这里的数据段差了5所以ds:[bx+5]就可以简化一下代码了
assume cs:code, ds:data, ss:stack	
data segment
		db 'BaSic'	;将第一个字符串转换成大写
		db 'Hello'	;将第二个字符串转换成小写
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov cx,5
upLetter:		mov al,ds:[bx]
		mov ah,ds:[bx+5]
		and al,11011111B
		or ah,00100000B
		mov ds:[bx],al
		mov ds:[bx+5],ah
		inc bx
		loop upLetter

		mov ax,4c00H
		int 21H

code ends

end start
内存的分配是整个汇编课程的最重要的东西,更灵活的访问内存了
上一章的题目程序如下,编写code段中的代码,将a段和b段中的数据依次相加,将结果存到c段中
assume cs:code
a segment
	db 1,2,3,4,5,6,7,8	;记着内存对齐最少16字节
a ends

b segment
	db 1,2,3,4,5,6,7,8
b ends

c segment
	db 0,0,0,0,0,0,0,0
c ends

code segment
start:		mov ax,0
		mov bx,0
		mov cx,8
		mov ax,a	;运行一次观察内存,就可以知道abc它们几个段的内存地址了,所以后边就不用b,c了
		mov ds,ax

addNumber:	mov al,ds:[bx]
		add al,ds:[bx+16]
		mov ds:[bx+32],al
		inc bx
		loop addNumber

		mov ax,4c00H
		int 21H

code ends

end start
要观察内存的排列得到一个规律,几块我们的程序运行速度
更灵活访问内存的方式

si和di偏移地址寄存器
先看一段代码,使用si和di实现将字符串'hello world'移动到......中
assume cs:code, ds:data, ss:stack	
data segment
		db 'Hello World'
		db '................'
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov si,0
		mov di,11

		mov cx,8
addNumber:	mov ax,ds:[si]
		mov ds:[di],ax
		add si,2
		add di,2
		loop addNumber	;也可以用栈来,还可以用es寄存器来,推荐es寄存器因为逻辑更清晰了

		mov ax,4c00H
		int 21H

code ends

end start

[bx+si]和[bx+di]
可以相加的,很简单就是寄存器中的值相加得到的偏移地址
自己去debug中做个小实验去
小实验:
数据段:2000:1000 be 00 06 00 6a 22 ......
mov ax,2000H
mov ds,ax
mov bx,0
mov bx,1000H
mov si,0
mov ax,ds:[bx+si]
inc si
mov cx,ds:[bx+si]
inc si
mov di,si
add cx,ds:[bx+di] = 0606

[bx+si+数字]和[bx+di+数字]
就是三个值相加得到偏移地址
小实验:
数据段:2000:1000 be 00 06 00 6a 22 ......
mov ax,2000H
mov ds,ax
mov bx,0
mov bx,1000H
mov si,0
mov ax,ds:[bx+si+2]
inc si  
mov cx,ds:[bx+si+2]
inc si
mov di,si
mov cx,ds:[bx+di+2] = 226a

不同的寻址方式的应用
编程1,将data段中每个单词的头一个字母改为大写,先看他在内存中的是怎么存放的
assume cs:code, ds:data, ss:stack
data segment
		db '1.file          '
		db '2.edit          '
		db '3.seach         '
		db '4.view          '
		db '5.options       '
		db '6.help          '
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov si,0

		mov cx,6
setNumber:	mov al,ds:[bx+2+si]
		and al,11011111B
		mov ds:[bx+2+si],al
		add si,16
		loop setNumber

		mov ax,4c00H
		int 21H

code ends

end start

编程2,将data段中每个单词的字母改为大写,先看他在内存中的是怎么存放的
要4行每行3个(0~2)
assume cs:code, ds:data, ss:stack
data segment
		db 'fil             '
		db 'edi             '
		db 'sch             '
		db 'vie             '
		dw 0	;尽量多一个出来有用来存东西最好少用寄存器,因为有限,或者用栈,栈比较好
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov cx,4
one:		push cx
		mov cx,3

two:		mov si,cx
		mov al,ds:[bx+si-1]
		and al,11011111B
		mov ds:[bx+si-1],al
		loop two	;(专业点 upRow)

		add bx,16
		pop cx
		loop one	;(同理upletter)

		mov ax,4c00H
		int 21H

code ends

end start

编程3,将data段中每个单词的前4个字母改为大写
与前一道题不同点:数据在内存中的分布不同
我们编写代码的时候 需要用不同的访问内存的方式 去访问这些数据
assume cs:code, ds:data, ss:stack
data segment
		db '1. display      '
		db '2. brows        '
		db '3. replace      '
		db '4. modify       '
		dw 0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov cx,4

one:		push cx
		mov si,0
		mov cx,4

two:		mov al,ds:[bx+3+si]
		and al,11011111B
		mov ds:[bx+3+si],al
		inc si
		loop two

		add bx,16
		pop cx
		loop one	;名字可以起的专业一点比如(upRow和upLetter)

		mov ax,4c00H
		int 21H

code ends

end start

这章的最后一课运行上面的代码,并改进,并作笔记
之所以重视数据在个地址内存中这个问题,是因为寻址方式的适当应用,使我们可以 以 一种 更合理的结构来看待 所要处理的数据
assume cs:code, ds:data, ss:stack
data segment
		db '1. display      '
		db '2. brows        '
		db '3. replace      '
		db '4. modify       '
		dw 0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov cx,4

one:		push cx
		;mov si,0	;不用si偏移地址寄存器,可以还用bx,但是需要入栈
		push bx
		mov cx,4

two:		;mov al,ds:[bx+3+si]	;数据在内存中 从哪里开始 逻辑清晰 阅读方便 偏移的思想
		mov al,ds:[bx+3]
		and al,11011111B
		;mov ds:[bx+3+si],al
		mov ds:[bx+3],al
		inc bx
		loop two

		;如果用到了入栈两次的话,需要注意先进后出的原则
		pop bx
		add bx,16
		pop cx
		loop one	;名字可以起的专业一点比如(upRow和upLetter)

		mov ax,4c00H
		int 21H

code ends

end start


不通过寄存器来确定数据的长度
1.怎么知道数据类型,看寄存器,是否是字节型和字型数据
你add或者inc这样加法也是不行的,因为有限度
mov bx:[0],1;该怎么放进去呢,没有类型的
mov word ptr ds:[0],1 ;可以这么写,意思是将16位的1发到ds:[0]的位置上去
mov byte ptr ds:[0],1 ;这个就是8位的1
同理适用于add inc sum......命令
这样不用通过寄存器就可以知道这个数据的长度了,word ptr是16位的, byte ptr是8位的

数据长度的练习
代码1.改变数据段中的值改成右边的想要的值
assume cs:code, ds:data, ss:stack
data segment
		db 'DEC'	;公司名
		db 'Ken 01sen'	;总裁名
		dw 137	;排名	-> 38
		dw 40	;收入	-> 增加70
		db 'PDP'	;著名产品	-> 'VAX'
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov word ptr ds:[12],38
		add word ptr ds:[14],70

		mov si,0
		mov bx,10H

		mov word ptr ds:[bx+si],'VA'
		add si,2
		mov byte ptr ds:[bx+si],'X'

		mov ax,4c00H
		int 21H

code ends

end start

div除法指令
除数: 有8位和16位两种,在一个寄存器或者内存单元中
被除数:	默认放在 ax 或者ax和dx中
	如果除数为8位,被除数为16位,默认存放在ax中
	如果除数为16位,被除数则为32位,dx存放高16位,ax存放低16位

开始思考,数据是有长度的,8位和16位
16	被除数
3	除数
5	商
1	余数

除数 03	被除数 0010H
被除数存放在 -> ax中
除数存放在->8位寄存器中 bl bh cl ch dl ch 或者 内存中
怎么用?
 寄存器是 div bl
 内存中是 div byte ptr ds:[0]	;8位数据
商存放在 ->al
余数放在 ->ah
代码
assume cs:code, ds:data, ss:stack
data segment
		db 3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		dw 0,0,0,0,0,0,0,0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,16
		mov bl,3
		div bl	;al=5 ah=1
		div byte ptr ds:[0]	;也行 

		mov ax,4c00H
		int 21H

code ends

end start

如果除数是16位,那么被除数是32位,那32位该怎么存放呢,dx存放高16位,ax存放低16位,ax存储除法的商,dx存储除法操作的余数
0003
00 00 00 10H
代码
assume cs:code, ds:data, ss:stack
data segment
		db 16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		dw 3,0,0,0,0,0,0,0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,ds:[0]
		mov dx,ds:[2]
		mov bx,3
		;div bx	;ax=5商 dx=1余
		div word ptr ds:[10H] ;这样也行

		mov ax,4c00H
		int 21H

code ends

end start

结果:	如果除数8位,则al存储除法操作的商,ah存储除法操作的余数
	如果除数为16位,则ax存储除法的商,dx存储除法操作的余数
开始做编程题,已知一个寄存器大小是65535
利用除法指令计算100001/100
assume cs:code, ds:data, ss:stack
data segment
		db 0a1H,86H,1,0,0,0,0,0,0,0,0,0,0,0,0,0
		dw 100,0,0,0,0,0,0,0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,ds:[0]
		mov dx,ds:[2]
		mov dx,100
		;div bx	;ax=03e8商 dx=1余
		div word ptr ds:[10H] ;这样也行

		mov ax,4c00H
		int 21H

code ends

end start

利用除法指令计算1001/100
assume cs:code, ds:data, ss:stack
data segment
		db e9H,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0
		dw 100,0,0,0,0,0,0,0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,ds:[0]
		mov bl,100
		;div bl	;al=a商 ah=1余
		div byte ptr ds:[10H] ;这样也行

		mov ax,4c00H
		int 21H

code ends

end start

如果是1001/256, 那需要的是16位的运算
assume cs:code, ds:data, ss:stack
data segment
		db 0e9H,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		dw 256,0,0,0,0,0,0,0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,ds:[0]
		mov dx,ds:[2]
		mov bx,256
		;div bl	;ax=3商 dx=0e9H余
		div word ptr ds:[10H] ;这样也行

		mov ax,4c00H
		int 21H

code ends

end start

div指令的一个问题
ax=0ffffH
dx=1
bx=1	;认为结果是dx=1 ax=0ffffH
div bx	;dx=余数 ax=商,有问题但过一会 会将 别急
会报错,原因是溢出

dd伪指令,是用来定义数据长度的和db,dw一样
db define byte	定义字节	8位
dw define word	定义字型	16位
dd define dword	定义双型节 	32位
dd define dword(double word)
编程题
用div计算data段中的第一数据除以第二个数据,上存放在第三个存储单元中
assume cs:code, ds:data, ss:stack
data segment
		dd 100001
		dw 100
		dw 0
data ends

stack segment stack
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
		dw 0,0,0,0
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,20H

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,ds:[0]
		mov dx,ds:[2]
		mov bx,ds:[4]
		;div bx
		div word ptr ds:[4]

		mov ax,4c00H
		int 21H

code ends

end start

dup伪指令,可以方便我们定义数据的时候太多要定义的数据时候用
可用在db dw dd 可重复定义前面的数据
假如要定义100字节型的0
db 100 dup (0)
假如是字符,那么是每一个字符是db类型并且重复10次
db 10 dup ('123','abc')
如果是dw dd呢
是以将每一个字符或者数据拼接在一起,然后最后计算类型,看看要不要内存对齐
可以看成每个字节都是db,dw,dd类型然后拼接在一起,最后看看是否需要内存对齐

数据访问的方式
学到这里汇编最重要的是什么
针对数据在内存中的排列 或者说分布 分配, 采取合适的 访问内存的方式 去读取数据 处理数据
数据处理的2个基本问题
数据的长度 byte ptr word ptr dd...
数据从哪里来 如mov ax,ds:[0],mov ax,es:[0]. 这种形式的段地址+偏移地址就可以
一些段地址有默认的偏移地址,反之 但我们可以强行的
如 ds的默认偏移地址是bx,ss的默认地址是bp 反之
代码
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,[bx]
		mov ax,ds:[si]
		mov ax,[bp]

		mov ax,ds:[bp+si]
		mov ax,ds:[bx*si/di-5]	;[里面数字]可以加减乘除,寄存器只能作加法运算

以上是访问内存的方式
		关键是数据在内存中的排列,自己怎么好受怎么来,要用合适的方式来访问

给出内存的方式
		有自定义的如 mov ax,1 叫立即数
		有十进制,字符型,十六进制,二进制的形式给立即数 ,为了让我们阅读方便
		mov ax,'a'
		mov al,'0ffH'
		mov al,00001111B

数据的传递到现在有两种,一种寄存器,另一种栈
		mov ax,bx
		mov dx,ax
		push bx
		push ds:[0]
		pop ds:[0]
		pop bx

采取格式访问内存的方式

		mov ax,4c00H
		int 21H

code ends

end start

实验7 寻址方式在结构化数据访问中的应用
编程 将data段中的数据 按照如下格式 写入到 table 段中, 并且计算21年中的人均收入(取整)
结果也按照下面的格式保存到table段中
assume cs:code,ds:data,ss:stack

data segment

		db	'1975','1976','1977','1978','1979','1980','1981','1982','1983'
		db	'1984','1985','1986','1987','1988','1989','1990','1991','1992'
		db	'1993','1994','1995'
		;以上是表示21年的21个字符串 year	不断的+4个字节

		dd	16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
		dd	345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
		;以上是表示21年公司总收入的21个dword数据	sum 不断+4个字节

		dw	3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
		dw	11542,14430,15257,17800
		;不断+2字节
		;employee
;思想,8位除法 还是16位除法 div寄存器 div内存 数据从哪里来 数据移动比较好 通过栈比较好 是寄存器比较好
;寄存器是够用的

data ends

table segment
		db	21 dup ('year summ ne ?? ')
table ends

stack segment stack
	db	128 dup (0)
stack ends

code segment

	start:	mov ax,stack
		mov ss,ax
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,table
		mov es,ax

		mov bx,0
		mov si,84	;看着乱的话可以写成21*4,4是dd,21是多少个,同样168可以写21*4+21*4,前一个21*4是dx的,后一个就是si了,然后从di开始
		mov di,168	;写代码的重要就是一眼可以看懂,168代表什么?可能是168个db型数据
		mov bp,0		;所以最好写成每个数据长度*个数,然后根据前面已有的数据和相加

		mov cx,21
		
copyNumber:	mov ax,ds:[bx]	;最好是[bx+0],因为这样你就可以知道赋值的就是低地址了,最好这样有着规范的写代码格式
		mov es:[bp],ax
		mov dx,ds:[bx+2]
		mov es:[bp+2],dx
		mov byte ptr es:[bp+4],' '

		mov ax,ds:[si]	;同理最好加[si+0]
		mov es:[bp+5],ax
		mov dx,ds:[si+2]
		mov es:[bp+7],dx
		mov byte ptr es:[bp+9],' '
		push word ptr es:[bp+5]
		push word ptr es:[bp+7]

		mov ax,ds:[di]
		mov es:[bp+10],ax
		mov byte ptr es:[bp+12],' '
		
		pop dx
		pop ax
		div word ptr es:[bp+10]
		mov es:[bp+13],ax
		mov byte ptr es:[bp+15],' '

		add bp,16
		add bx,4	;优化,因为年份和利润的类型都是一样的都是dd所以用[bx+21*4]这样的偏移地址就可以了,可以剩下一个寄存器了
		add si,4
		add di,2
		loop copyNumber

		mov ax,4C00H
		int 21H

code ends

end start
优化,最好用栈移动数据,栈是16位的大小
最好把大的数字写成 每个数据长度*个数,然后根据前面已有的数据和相加
自己优化去

承上启下(非常重要)
实验七的启发两层意思
一层 采取适合的访问内存的方式 去访问呢 这些结构化的数据
两层 这些经过 结构化的数据 编写代码去 访问它们的时候 特别方便
这些数据被 结构化了
我们可以将这些零散的数据 机构化
拿到段地址,然后用偏移的思想,给我们以后编写代码带来了方便
不要去 被动的接收数据 将这些数据结构化 为了我们后面编写代码 提供方便
不就是 数据从哪里来 数据处理 数据从哪里来
代码的好坏与这个数据组织的合理不合理 有关 结构好不好 有关
数据结构专门去讲数据的组织的,不过我会嘿嘿嘿...
我们以后的章节
第九章 转移指令的原理
第十章 call和ret指令
第九章前面讲的是数据的组织
之后讲的是代码的组织 也可以说 指令的组织
代码的组织 指令的组织 对编程的提高是很重要的 相当于函数


转移指令的原理
转移指令就是可以修改ip 或者同时修改cs和ip的
jmp	无条件转移指令
loop	有条件转移指令	cx寄存器值
call 下一章讲
cpu执行 机器码 平时编程是汇编指令
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,1000H
		jmp s
		mov bx,1000H

s:		mov ax,1000H	;eb04 0019

		mov ax,4c00H
		int 21H

code ends

end start
在不同位置的jmp,产生的编码和跳转目标的地址发生了变化
为什么会这样

offset操作符
offset的功能是取得标号处的偏移地址,也就是start:这个标号的地址
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

s:		mov ax,offset start
		mov bx,offset s

		mov ax,4c00H
		int 21H

code ends

end start

问题
有如下程序段,添加 两条指令是改程序运行中将 s处的一条指令复制到s0处
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

s:		mov ax,bx	;占两个字节
		mov si,offset s
		mov di,offset s0

		mov dx,cs:[si];-----------
		mov cs:[di],dx;-----------	

s0:		nop	;每个nop占一个字节
		nop

		mov ax,4c00H
		int 21H

code ends

end start

jmp指令原理
上面遗留下的问题
在不同位置的jmp,产生的编码和跳转目标的地址发生了变化
为什么会这样
先回忆下指令的执行过程
读取这个,并存放到指令缓存器中
然后ip = ip+所读指令的字节数,也就是下一个地址
执行指令缓存器中的内容然后跳转到第一步
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		jmp s
		mov bx,1000H
		;mov bx,1000H
		;mov bl,0

s:		mov ax,1000H	;eb04 eb07 eb09
		;jmp跳转指令编译后的 机器码 和 指令的长度有关
		;就是如eb07,eb08,eb09,它们后面的07 08 09都是从这个jmp指令到目标的字节长度
		;在用debug看了之后发现jmp下一条指令是nop的汇编指令.但jmp编译后的机器码是和nop的偏移地址相加等于jmp目标跳转的偏移地址
		;通过这么一种方式cpu在执行jmp指令的时候 并不需要跳转的 目的地址 就可以实现对ip寄存器的修改		
		;只需要做一个加法运算就可以了
		;标号地址(也就是start:) - jmp指令后第一个字节的地址(也就是jmp后第一个nop指令地址)

		mov ax,4c00H
		int 21H

code ends

end start

jmp指令原理可能的一个问题
如果jmp是往上跳呢?
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

s:		mov ax,1000H
		jmp s
;15+fb=10
;标号地址 - jmp指令后的第一个字节的地址 = fb 15+fb(-5) = 10
;为什么是fb可以看成是-5呢,因为计算机中没有减法 但是加上一个 负数不就可以了吗
;而负数是怎么表现的呢, 将一个正数 变成二进制 后 按位取反(0变1 1变0) 加上1

		mov ax,4c00H
		int 21H

code ends

end start

jmp指令跳转范围
只有一个字节 也叫位移范围
一个字节有8个二进制位也叫8位位移 -128-127
有8位位移也有16位位移 -32768-32767
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

s:		mov ax,1000H
		db 130 dup(0)
		jmp s
		;这样的时候8位位移就会自动变成16位位移了
		;但你可以指定,不过不推荐 short ptr 8位 near ptr 16位
		;都是加在jmp的后面指标(s)的前面 和用内存访问特定的数据长度一样

		mov ax,4c00H
		int 21H

code ends

end start

实验8 分析一个奇怪的程序
分析下卖弄的程序,在运行前思考,这个程序可以正确返回吗
运行后在思考,为什么是这种结果
通过这个程序加深对相关内容的理解
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
		mov ax,4c00H
		int 21H

		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,4c00H	;3
		int 21H	;2
start:		mov ax,0	;3
s:		nop	;cpu遇到nop指令 什么都不做 占一个字节
		nop	;然后s2被赋值到这里就是eb f6,为什么不是反着写的呢,因为jmp被翻译过后是eb,不能把指令和指令中数据写反,编译器执行这个jmp指令知道从下一个命令执行前开始向前移动10个字节的长度

		mov di,offset s
		mov si,offset s2
		mov ax,cs:[si]
		mov cs:[di],ax

s0:		jmp short s

s1:		mov ax,0	;3
		int 21H	;2
		mov ax,0	;3

s2:		jmp short s1	;短转移指令 -128~127 ebxx(xx代表移动范围) 2 得出结论xx=-10=f6

		nop	;offset 这个 + xx(-10)

		mov ax,4c00H
		int 21H

code ends

end start

jcxz条件转移指令
j=jmp cx=cx寄存器 z=zero=0
类似于c中if(cx=0)goto
当cx寄存器中的值=0的时候进行跳转
loop指令 cx中的值不等于0的时候 进行跳转
所有的条件的转移指令 都是短转移 位移范围 -128~127
经过编译后 机器码中 包含了位移的范围
之前学的jmp=ebxx xx位移范围 在编译器在编译的时候计算的 计算方法是:目标标号处的偏移地址 - jmp指令后第一个字节地址
就是当cx=0的时候进行jmp 位移范围是-128~127 编译器编译的时候计算

监测点 补全程序 利用jcxz指令,实现在内存2000H 段中查找第一个值为0的字节,找到后,将他的偏移地址 存储到dx中
2000H读取字节数据 cx=ch+cl 让cx=0 那必须ch=0 和 cl=0 
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,2000H
		mov ds,ax
		mvo bx,0

s:		mov ch,0;-----------
		mov cl,ds:[bx];-----------
		jcxz ok;-----------
		inc bx;-----------
		jmp short s

ok:		mov dx,bx

		mov ax,4c00H
		int 21H

code ends

end start

loop条件转移指令
符合规则
所有的条件的转移指令 都是短转移 位移范围 -128~127
编译器编译的时候计算出来的
cx -= 1
判断cx是否等于0
不等于0则进行循环
等于0则继续执行下面的程序
但要小心超过溢出如0-1=ffff

监测点 补全程序 利用loop指令,实现在内存2000H 段中查找第一个值为0的字节,找到后,将他的偏移地址 存储到dx中
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,2000H
		mov ds,ax
		mvo bx,0

s:		mov cl,ds:[bx]
		mov ch,0
		inc cx;----------
		inc bx
		loop s

ok:		dec bx	;讲bx中的值-1
		mov dx.bx

		mov ax,4c00H
		int 21H

code ends

end start

转移目的地地址在 机器码或 寄存器中
位移的方式
机器码中没有包含转移的目的地址 位移的范围
转移的目的地址在机器码中的jmp指令
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		jmp far ptr s	;far是调用不同段的函数的,在同一段好像和near没区别
		db 256 dup (0)

s:		mov ax,1000H

		mov ax,4c00H
		int 21H

code ends

end start

转移的目的地址在寄存器中的jmp指令
就是mov ax, 2233H
jmp ax

转移目的地址在 内存中
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		;mov ax,2233H
		;mov ds:[0],ax

		;mov word ptr ds:[2],4455H

		;jmp word ptr ds:[0]	;ip=ds:[0]的字型数据
		;jmp dword ptr ds:[0]	;ip=ds:[0]的字型数据 cs=ds:[2]的字型数据
		;但这样写太佬了,没有一点函数的感觉,提示函数指针和代码模块化

		mov ax,offset s1
		mov ds:[0],ax
		mov ax,offset s2
		mov ds:[2],ax
		mov ax,offset s3
		mov ds:[4],ax
		;我们是不是将这些偏移全部当作 数据来处理了, 结构化,bx值可以修改
		;非常重要 组织代码的方式 组织指令的方式
		;地址也是一种数据,而数是可以结构化的 我们通过这一种方式访问这些指令 逻辑上很清晰 是一种组织代码的方式
	
		jmp word ptr ds:[bx]	;ip=ds:[0]的字型数据


over:		mov ax,4c00H
		int 21H

s1:		mov ax,1000H
		jmp over
s2:		mov ax,1001H
		jmp over
s3:		mov ax,1002H
		jmp over

code ends

end start

监测点9.1
1.程序如下 若要使程序中jmp子陵执行后,cs:ip指向程序的第一条指令,在data段 应该如何定义数据
assume cs:code, ds:data, ss:stack
data segment
		db 0
		;dw 0	;ds:[1]用dw表示 阅读上的方便
		dw offset start	;还可以这么写
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		jmp word ptr ds:[bx+1]	;ip=ds:[bx+1]=ds:[1]=offset start =0


		mov ax,4c00H
		int 21H

code ends

end start

2.程序如下 补全程序 使用jmp中兴后,cs ip 指向程序的第一条指令
assume cs:code, ds:data, ss:stack
data segment
		dd 12345678H
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov word ptr ds:[bx+0],offset start;------
		mov ds:[bx+2],cs;------

		jmp dword ptr ds:[0]	;ip=ds:[0] cs=ds:[2]

		mov ax,4c00H
		int 21H

code ends

end start

3.用debug查看内存 结果如下
2000:1000 be 00 06 00 00 00 ......
则此时,cpu执行指令
mov ax,2000H
mov es,ax
jmp dword ptr es:[1000H]
cs = ? ip = ?	cs=0006H ip=00beH
最重要,地址也是数据

实验9 材料分析
编程:在屏幕中间分别显示 绿色,绿底红字,白底蓝字 的字符串 'welcome to masm!'
变成所需的知识通过阅读,分析下面的材料获得!!!
80×25彩色字符模式显示缓冲区(一下简称为显示缓冲区)的结构:
内存地址空间中,b800H~bfffH共32K的空间,为80×25彩色字符模式的显示缓冲区域.像这个地址空间写入数据
写入的内容将立即出现在显示器上
80×25彩色字符模式下,显示器可以显示25行,每行80个字符,每个可以有256种属性
这样,一个字符在显示缓冲区种就要占用两个字节,分别存放字符和ascii码和属性
80×25模式下,一切屏幕内容在显示缓冲区中 共占4000个字节
显示缓冲区分为8页,每页4kb(约等于4000b),显示器可以显示任意一页的内容,一般情况下,显示第0页的内容
0000 0000 字符属性占用一个字节
7654 3210 对应上面字符的每个位的编号
rgb   tgb
背景  前景
背景=dise
前景=字体颜色
7 闪烁	只有全屏dos下才能看到效果
3 高亮
r=red
g=green
b=blue
如:	底色 字体颜色
红底绿字:	0100 0010B
红底高亮绿字0100 1010B
黑底白字: 0000 0111B
白底黑字: 0111 0000
经过相似debug中实验
发现ascii码在100H,102H,104H 位置存放
存放字符颜色在101H,103H,105H 位置存放
偶数地址都是存放字符的ascii码
奇数地址都是存放字符的颜色 字符的属性
屏幕上的位置:
一共80个字符	每行160个字节
一个屏幕有25行显示	一共4000字节
如何去组织数据
如何去处理数据
可以这么理解,以字型为单元核心,低地址存放ascii码值 高地址存放字符的属性
assume cs:code, ds:data, ss:stack
data segment
		db 'welcome to masm!'	;ds:[si]
		db 00000010B	;0000 0000 ds:[bx]
		db 00100100B	; rgp
		db 01110001B
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov bx,0b800H
		mov es,bx

		mov si,0	;字符
		mov di,160*10 + 30*2	;偶数地址存放ASCII
		mov bx,16	;属性
		mov dx,0	;保存移动的字符属性

		mov cx,3
showMasm:	push cx
		push bx
		push si
		push di

		mov cx,16
		mov dh,ds:[bx]	;mov es:[di],dx es:[di+0],dl es:[di+1],dh

showRow:		mov dl,ds:[si]
		mov es:[di],dx
		add di,2
		inc si
		loop showRow

		pop di
		pop si
		pop bx
		pop cx
		add di 160
		inc bx
		loop showMasm

		mov ax,4c00H
		int 21H

code ends

end start

根据位移进行转移的指令的优势
根据位移 来修改ip寄存器 进行转移 指令的优势
jmp标号
jmp short 标号
jmp near 标号
jcxz 标号
loop 标号
位移 = 标号处的偏移地址 - 转移指令后的第一个字节的地址
转移指令后的第一个字节的地址+标号处的偏移地址=位移
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment
start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

;为什么是指令后的第一个字节的地址呢,是因为指令的执行过程
;根据位移, 位移就是 = 转移指令后的第一个字节的地址+标号处的偏移地址,这种方法使用与内存中任何位置
;因为在执行这种带有 位移的转移指令时,只根据位移来计算
		call cpy_tetris

		mov bx,0
		push bx
		mov bx,07e00H
		push bx

		mov bx,sp
		jmp dword ptr ss:[bx+0]

		mov ax,4c00H
		int 21H
;==================================

tetris:		jmp s
		mov ax,1000H

s:		add bx,0
tetris_end:		nop
;====================================

cop_tetris:		mov bx,cs
		mov ds,bx
		mov si,offset tetris

		mov bx,0
		mov es,bx
		mov di,7e00H

		mov cx,offset tetris_end - offset tetris

cpytetris:		mov al,ds:[si]
		mov es:[di],al
		inc si
		inc di
		loop cpytetris	

		ret
code ends

end start
还有以数据的形式存储,就是地址存到内存中 结构化存放,各有各的优势,以后要组织代码组织指令的方式
地址以数据的形式存储就是以前写的这个
assume cs:code, ds:data, ss:stack
data segment
		db 128 dup (0)
data ends

stack segment stack
		db 128 dup (0)
stack ends

code segment

start:		mov bx,stack
		mov ss,bx
		mov sp,128

		mov bx,data
		mov ds,bx
		mov bx,0

		mov ax,offset s1
		mov ds:[0],ax
		mov ax,offset s2
		mov ds:[2],ax
		mov ax,offset s3
		mov ds:[4],ax
	
		jmp word ptr ds:[bx]	;ip=ds:[0]的字型数据

over:		mov ax,4c00H
		int 21H

s1:		mov ax,1000H
		jmp over
s2:		mov ax,1001H
		jmp over
s3:		mov ax,1002H
		jmp over

code ends

end start

指令长度的计算方式的思考
道理102-100,非常简单

实验9 中学到的东西
对比实验7
实验7数据是给你准备好的,实验9需要自己手动去准备
提炼材料的过程叫 抽象
像:你给了我一个苹果,然后又给了我一个苹果,问 你总共给了我几个苹果
1+1 = 2 这个过程叫抽象
1是数据 + add 代码 指令 表名了 这两个数据之间的关系
如何组织数据 如何组织代码
1.不要急
2.多想
3.多写
4.循环
把一个大的问题切割成一个一个小的问题 下一章call指令 切割问题 切割代码
一个完备的程序要重新写好几次

