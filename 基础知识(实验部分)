详细笔记在思维导图中
实验
-debug
-a
mov ax,5
mov ax,0
mov al,5
会自动给你补齐相应的位数

mov ax,1a2b
mov bx,ax
mov ch,bl
mov cl,bh
mov dl,ch
mov ax,dx
数据域寄存器之间要 保证一致性,8位寄存器给8位寄存器,8位数据给8位寄存器,16位数据给16位寄存器,16位寄存器给16位寄存器. 如果数据超出8位或者16位的话会报错

mov ax,bl
mov bh,ax
mov al,100H
mov ax,10000H
mov al,0005H
数据域寄存器之间要 保证一致性,这几条指令都没有保证一致性
(数据前面写0如果超了也不行,如果前面不写0,编译器会自动给你补齐,所以没事就不要在前面写0)

加法超过最大值会这么样
(要保证数据之间的一致性我们的编译器会把写的数如果不和前面的位寄存器相对应的话,会补齐成相应的位数,并且都是用的是16进制)
mov ax,08
mov ah,78
add ax,8
指令add是加法运算,就是逗号右边的值加上逗号左边的值,然后逗号左边的值等于右边已经加过的值,类似于C语言中的+=
最后得到的是ax=7810(因为是16进制)

mov bx,ax
add ax,bx

mov ax,0
mov ax,93
add al,85
溢出了,看到的是高位舍弃,但是前面的溢出值跑到其他的地方去了

mov ax,0
mov al,93
add ax,85
16位寄存器进行16位运算保存16位数据
没有溢出,因为加在ax上,ax上是4个十六进制数字,所以没有溢出
寄存器是互相独立的,al就是al,ah就是ah,ax就是ax不会互相影响

mov ax,4e20
add ax,1406
mov bx,2000
add ax,bx
mov bx,ax
add ax,bx
最后明显超过了,溢出了,只能保存后面的16位进制
寄存器是互相独立的,al就是al,ah就是ah,ax就是ax不会互相影响

add al,100
add ax,10000
add al,bx
是不行的因为,韩信带净化,要保证 数据与寄存器 或者 寄存器与寄存器 之间的一致性

练习自己找或者自己出题练习去
mov ax,f4a3
mov ah,31
mov al,23
add ax,ax
mov bx,826c
mov cx,ax
mov ax,bx
add ax,bx
mov al,bh
mov ah,bl
add ah,ah
add a1,6
add al,al
mov ax,cx
最后得到的是ax=6246

用汇编指令计算2^4次方
mov ax,0
mov al,2
add al,al
add al,al
add al,al

ax,bx,cx,dx都是数据寄存器
地址寄存器
